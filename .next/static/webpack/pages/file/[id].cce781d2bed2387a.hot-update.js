"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/file/[id]",{

/***/ "./utils/glossaryUtils.js":
/*!********************************!*\
  !*** ./utils/glossaryUtils.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"detectGlossary\": function() { return /* binding */ detectGlossary; },\n/* harmony export */   \"detectGlossarySource\": function() { return /* binding */ detectGlossarySource; },\n/* harmony export */   \"displayAsHTML\": function() { return /* binding */ displayAsHTML; },\n/* harmony export */   \"sortGlossaryList\": function() { return /* binding */ sortGlossaryList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./utils/utils.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/server */ \"./node_modules/react-dom/server.browser.js\");\n\n\n\nconst replacementCode = \"XxcD5JZ73PDgM4PBDWYtfKMKAakSuRsG\";\nfunction replacementFunction(m) {\n    return replacementCode.repeat(m.length);\n}\nconst replaceTextWithGlossary = (text, termMatchGlossary, termList, sourceCell, glossary, originalTermList)=>{\n    let newText = text;\n    let increasedTooltip = 0;\n    const termMatchGlossarySource = detectGlossarySource(sourceCell, glossary, sourceCell, originalTermList, \"source\");\n    console.log(\"wutt\", termMatchGlossarySource);\n    termMatchGlossary.forEach((param)=>{\n        let [i, termMatch] = param;\n        let tranlationOfTerm, sourceOfTerm, termNote;\n        let sourceTermAppear = false;\n        for (const term of termList){\n            if (term.sourceValues.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                tranlationOfTerm = term.translations;\n                termNote = term.note;\n                break;\n            } else if (term.translations.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                sourceOfTerm = term.sourceValues;\n                termNote = term.note;\n                break;\n            }\n        }\n        if (text === \"string v\\xe0 Kabbalah c\\xf5i\") {\n            console.log(\"sourceOfTerm\", sourceOfTerm);\n            console.log(\"sourceCell\", sourceCell);\n            console.log(\"termMatchGlossarySource\", termMatchGlossarySource);\n        }\n        sourceTermAppear = sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.some((value2)=>{\n            return termMatchGlossarySource === null || termMatchGlossarySource === void 0 ? void 0 : termMatchGlossarySource.some((param)=>{\n                let [_, value1] = param;\n                return value1.toLowerCase() === value2.toLowerCase();\n            });\n        });\n        const tooltipContent = (0,react_dom_server__WEBPACK_IMPORTED_MODULE_2__.renderToString)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            className: \"glossary-tooltip\",\n            children: [\n                termMatch,\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"tooltip\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: termMatch\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 69,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"translateValue\",\n                            children: sourceOfTerm ? sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.join(\", \") : tranlationOfTerm === null || tranlationOfTerm === void 0 ? void 0 : tranlationOfTerm.join(\", \")\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 70,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"note\",\n                            children: termNote\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 75,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                    lineNumber: 68,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n            lineNumber: 66,\n            columnNumber: 7\n        }, undefined));\n        if (sourceOfTerm && sourceTermAppear || !sourceOfTerm) {\n            newText = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.replaceTextAtIndex)(newText, i + increasedTooltip, termMatch.length, tooltipContent);\n            increasedTooltip = increasedTooltip + tooltipContent.length - termMatch.length;\n        }\n    });\n    return newText;\n};\nfunction displayAsHTML(textAreaText, termMatchGlossary, termList, sourceCell, termMatchGlossarySource, originalTermList) {\n    let textWithGlossary = replaceTextWithGlossary(textAreaText, termMatchGlossary, termList, sourceCell, termMatchGlossarySource, originalTermList);\n    let textWithSpacesBeforePunctuationReplaced = textWithGlossary.replace(/ +(?=[\\.\\!\\?])/g, replacementFunction);\n    // bôi đen những chỗ có hơn hai dấu cách liền.\n    let textWithSpacesReplaced = textWithSpacesBeforePunctuationReplaced.replace(RegExp(\"(?<= ) +\", \"g\"), replacementFunction);\n    // khi nào dấu cách thừa xuất hiện ngay sau dấu . ? !, mình thay thế dấu ⎵ đầu tiên bằng &nbsp; để cho phép user có hai dấu cách sau . ? !.\n    const regex = new RegExp(\"(?<=[.?!]) \" + replacementCode, \"g\");\n    let textAllowingDoubleSpaceAfterEndOfSentence = textWithSpacesReplaced.replace(regex, \" &nbsp;\");\n    // thay thế các dấu cách thừa bằng dấu ⎵ màu dỏ\n    let textWithSpacesAsUnderscores = textAllowingDoubleSpaceAfterEndOfSentence.replaceAll(replacementCode, \"<font color=#F00>⎵</font>\");\n    return textWithSpacesAsUnderscores;\n}\nfunction sortGlossaryList(glossary) {\n    glossary.forEach(function(term, i) {\n        glossary[i] = term.toLowerCase();\n    });\n    return glossary.sort((a, b)=>b.length - a.length);\n}\n/**\n * A complete match of term in string is when term matches a complete word or\n * phrase in string and no partial words in string are left hanging off the\n * start or end. For example, if term is \"full\" and string is \"beautifully\", that\n * is not a complete match because \"beauti\" hangs off the beginning and \"y\" extends\n * before the start of the section of matching text.\n **/ function completeMatchBoundaries(string, startIndex, segmenter, term) {\n    // initialize values for output\n    // this is the output as it should be if no match is found\n    let matchBoundaries = {\n        naiveMatch: false,\n        completeMatch: false,\n        naiveMatchStart: -1,\n        naiveMatchEnd: -1,\n        completeMatchStart: -1,\n        completeMatchEnd: -1\n    };\n    // find a match by simple string search, starting at startIndex.\n    let unsearchedPartOfString = string.substring(startIndex);\n    let matchIndex = unsearchedPartOfString.indexOf(term) + startIndex;\n    // if no simple match was found, return\n    if (matchIndex < startIndex) return matchBoundaries;\n    // if we reach this point then a naive match was found.\n    // update naive match boundary information accordingly.\n    matchBoundaries.naiveMatch = true;\n    matchBoundaries.naiveMatchStart = matchIndex;\n    matchBoundaries.naiveMatchEnd = matchIndex + term.length - 1;\n    // segment the string\n    let stringSegments = segmenter.segment(string);\n    // get the string segment that contains the match index.\n    // this is the first word in string that matches term\n    let firstMatchingSegment = stringSegments.containing(matchIndex);\n    // if the index of the matching segment doesn't match the matchIndex found\n    // by naive search, it's a partial match. Return the boundary info as-is\n    // without complete match data.\n    if (firstMatchingSegment.index < matchIndex) return matchBoundaries;\n    /**\n   * at this point we know that the first character in \"term\" is the first\n   * character of a segment in string. now we need to check if the last character\n   * in \"term\" is also aligned with the last character of a segment in string.\n   **/ // get the string segment that contains the last character of term\n    let lastMatchingSegment = stringSegments.containing(matchBoundaries.naiveMatchEnd);\n    // get the index of the last character of that string segment\n    let endOfLastMatchingSegment = lastMatchingSegment.index + lastMatchingSegment.segment.length - 1;\n    // if the end of the last matching segment matches with the end of the naive \"indexOf\"\n    // match then the match is a complete match with no extra word characters hanging\n    // off the start or end.\n    if (endOfLastMatchingSegment == matchBoundaries.naiveMatchEnd) {\n        // update the complete match boundary info\n        matchBoundaries.completeMatch = true;\n        matchBoundaries.completeMatchStart = firstMatchingSegment.index;\n        matchBoundaries.completeMatchEnd = endOfLastMatchingSegment;\n    }\n    return matchBoundaries;\n}\n/**\n * Searches \"string\" for terms in \"glossary\" and gives the location where each term appears. If several glossary terms overlap, matching on the same words then the longest term takes precedence.\n *\n * @param string - the text string in which we want to search for glossary terms\n * @param glossary - an array of text strings, all the terms in the glossary. This list may contain several thousand items.\n * @param languageCode - ISO 639-1 language code\n * @returns {array} - a list of pairs [index, term] where int is the index at which term appears in string.\n **/ function glossaryMatches(string, allGlossary) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, textInfo = arguments.length > 3 ? arguments[3] : void 0, originalTermList = arguments.length > 4 ? arguments[4] : void 0;\n    // make a copy of string so that the original is not lost when we modify it\n    let stringCopy = string;\n    // if the search is not case-sensitive, convert everything to lower case\n    if (!caseSensitive) {\n        string = string.toLowerCase();\n    }\n    // split the string into segments, separating by word\n    let segmenter = new Intl.Segmenter(textInfo.language, {\n        granularity: \"word\"\n    });\n    let output = Array(0);\n    // for each list of terms in the sorted glossary\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.srcGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].sourceLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.targetGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].targetLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    // sort the output by the indices and return\n    return output.sort((a, b)=>a[0] - b[0]);\n}\nconst detectGlossarySource = (source, glossary, textInfo, originalTermList)=>{\n    let caseSensitive = false;\n    if (source === null || source === void 0 ? void 0 : source.value) {\n        return glossaryMatches(source === null || source === void 0 ? void 0 : source.value, glossary, caseSensitive, textInfo, originalTermList);\n    } else {\n        return [];\n    }\n};\nconst detectGlossary = (text, glossary, textInfo, originalTermList, source)=>{\n    let caseSensitive = false;\n    if (text) {\n        return glossaryMatches(text, glossary, caseSensitive, textInfo, originalTermList);\n    } else {\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxHQUFHaEIsSUFBTWdCLENBQUMsQ0FBQyxFQUFFLEdBQUdoQixDQUFDLENBQUMsRUFBRTtBQUMxQztBQUVPLE1BQU12Qix1QkFBdUIsQ0FDbENnRixRQUNBckYsVUFDQXNFLFVBQ0FyRSxtQkFDRztJQUNILElBQUlvRSxnQkFBZ0IsS0FBSztJQUV6QixJQUFJZ0IsbUJBQUFBLG9CQUFBQSxLQUFBQSxJQUFBQSxPQUFRbkUsS0FBSyxFQUFFO1FBQ2pCLE9BQU9pRCxnQkFDTGtCLG1CQUFBQSxvQkFBQUEsS0FBQUEsSUFBQUEsT0FBUW5FLEtBQUssRUFDYmxCLFVBQ0FxRSxlQUNBQyxVQUNBckU7SUFFSixPQUFPO1FBQ0wsT0FBTyxFQUFFO0lBQ1gsQ0FBQztBQUNILEVBQUU7QUFFSyxNQUFNcUYsaUJBQWlCLENBQzVCMUYsTUFDQUksVUFDQXNFLFVBQ0FyRSxrQkFDQW9GLFNBQ0c7SUFDSCxJQUFJaEIsZ0JBQWdCLEtBQUs7SUFFekIsSUFBSXpFLE1BQU07UUFDUixPQUFPdUUsZ0JBQ0x2RSxNQUNBSSxVQUNBcUUsZUFDQUMsVUFDQXJFO0lBRUosT0FBTztRQUNMLE9BQU8sRUFBRTtJQUNYLENBQUM7QUFDSCxFQUFFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3V0aWxzL2dsb3NzYXJ5VXRpbHMuanM/OGQ4NyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyByZXBsYWNlVGV4dEF0SW5kZXggfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgcmVuZGVyVG9TdHJpbmcgfSBmcm9tIFwicmVhY3QtZG9tL3NlcnZlclwiO1xuXG5jb25zdCByZXBsYWNlbWVudENvZGUgPSBcIlh4Y0Q1Slo3M1BEZ000UEJEV1l0ZktNS0Fha1N1UnNHXCI7XG5cbmZ1bmN0aW9uIHJlcGxhY2VtZW50RnVuY3Rpb24obSkge1xuICByZXR1cm4gcmVwbGFjZW1lbnRDb2RlLnJlcGVhdChtLmxlbmd0aCk7XG59XG5cbmNvbnN0IHJlcGxhY2VUZXh0V2l0aEdsb3NzYXJ5ID0gKFxuICB0ZXh0LFxuICB0ZXJtTWF0Y2hHbG9zc2FyeSxcbiAgdGVybUxpc3QsXG4gIHNvdXJjZUNlbGwsXG4gIGdsb3NzYXJ5LFxuICBvcmlnaW5hbFRlcm1MaXN0XG4pID0+IHtcbiAgbGV0IG5ld1RleHQgPSB0ZXh0O1xuICBsZXQgaW5jcmVhc2VkVG9vbHRpcCA9IDA7XG5cbiAgY29uc3QgdGVybU1hdGNoR2xvc3NhcnlTb3VyY2UgPSBkZXRlY3RHbG9zc2FyeVNvdXJjZShcbiAgICBzb3VyY2VDZWxsLFxuICAgIGdsb3NzYXJ5LFxuICAgIHNvdXJjZUNlbGwsXG4gICAgb3JpZ2luYWxUZXJtTGlzdCxcbiAgICBcInNvdXJjZVwiXG4gICk7XG4gIGNvbnNvbGUubG9nKFwid3V0dFwiLCB0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZSk7XG5cbiAgdGVybU1hdGNoR2xvc3NhcnkuZm9yRWFjaCgoW2ksIHRlcm1NYXRjaF0pID0+IHtcbiAgICBsZXQgdHJhbmxhdGlvbk9mVGVybSwgc291cmNlT2ZUZXJtLCB0ZXJtTm90ZTtcbiAgICBsZXQgc291cmNlVGVybUFwcGVhciA9IGZhbHNlO1xuXG4gICAgZm9yIChjb25zdCB0ZXJtIG9mIHRlcm1MaXN0KSB7XG4gICAgICBpZiAoXG4gICAgICAgIHRlcm0uc291cmNlVmFsdWVzLnNvbWUoXG4gICAgICAgICAgKHZhbHVlKSA9PiB2YWx1ZS50b0xvd2VyQ2FzZSgpID09PSB0ZXJtTWF0Y2gudG9Mb3dlckNhc2UoKVxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgdHJhbmxhdGlvbk9mVGVybSA9IHRlcm0udHJhbnNsYXRpb25zO1xuICAgICAgICB0ZXJtTm90ZSA9IHRlcm0ubm90ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2UgaWYgKFxuICAgICAgICB0ZXJtLnRyYW5zbGF0aW9ucy5zb21lKFxuICAgICAgICAgICh2YWx1ZSkgPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdGVybU1hdGNoLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHNvdXJjZU9mVGVybSA9IHRlcm0uc291cmNlVmFsdWVzO1xuICAgICAgICB0ZXJtTm90ZSA9IHRlcm0ubm90ZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRleHQgPT09IFwic3RyaW5nIHbDoCBLYWJiYWxhaCBjw7VpXCIpIHtcbiAgICAgIGNvbnNvbGUubG9nKFwic291cmNlT2ZUZXJtXCIsIHNvdXJjZU9mVGVybSk7XG4gICAgICBjb25zb2xlLmxvZyhcInNvdXJjZUNlbGxcIiwgc291cmNlQ2VsbCk7XG4gICAgICBjb25zb2xlLmxvZyhcInRlcm1NYXRjaEdsb3NzYXJ5U291cmNlXCIsIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlKTtcbiAgICB9XG4gICAgc291cmNlVGVybUFwcGVhciA9IHNvdXJjZU9mVGVybT8uc29tZSgodmFsdWUyKSA9PlxuICAgICAgdGVybU1hdGNoR2xvc3NhcnlTb3VyY2U/LnNvbWUoXG4gICAgICAgIChbXywgdmFsdWUxXSkgPT4gdmFsdWUxLnRvTG93ZXJDYXNlKCkgPT09IHZhbHVlMi50b0xvd2VyQ2FzZSgpXG4gICAgICApXG4gICAgKTtcblxuICAgIGNvbnN0IHRvb2x0aXBDb250ZW50ID0gcmVuZGVyVG9TdHJpbmcoXG4gICAgICA8c3BhbiBjbGFzc05hbWU9XCJnbG9zc2FyeS10b29sdGlwXCI+XG4gICAgICAgIHt0ZXJtTWF0Y2h9XG4gICAgICAgIDxzcGFuIGNsYXNzTmFtZT1cInRvb2x0aXBcIj5cbiAgICAgICAgICA8Yj57dGVybU1hdGNofTwvYj5cbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT1cInRyYW5zbGF0ZVZhbHVlXCI+XG4gICAgICAgICAgICB7c291cmNlT2ZUZXJtXG4gICAgICAgICAgICAgID8gc291cmNlT2ZUZXJtPy5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICAgOiB0cmFubGF0aW9uT2ZUZXJtPy5qb2luKFwiLCBcIil9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJub3RlXCI+e3Rlcm1Ob3RlfTwvZGl2PlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L3NwYW4+XG4gICAgKTtcblxuICAgIGlmICgoc291cmNlT2ZUZXJtICYmIHNvdXJjZVRlcm1BcHBlYXIpIHx8ICFzb3VyY2VPZlRlcm0pIHtcbiAgICAgIG5ld1RleHQgPSByZXBsYWNlVGV4dEF0SW5kZXgoXG4gICAgICAgIG5ld1RleHQsXG4gICAgICAgIGkgKyBpbmNyZWFzZWRUb29sdGlwLFxuICAgICAgICB0ZXJtTWF0Y2gubGVuZ3RoLFxuICAgICAgICB0b29sdGlwQ29udGVudFxuICAgICAgKTtcbiAgICAgIGluY3JlYXNlZFRvb2x0aXAgPVxuICAgICAgICBpbmNyZWFzZWRUb29sdGlwICsgdG9vbHRpcENvbnRlbnQubGVuZ3RoIC0gdGVybU1hdGNoLmxlbmd0aDtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBuZXdUZXh0O1xufTtcbmV4cG9ydCBmdW5jdGlvbiBkaXNwbGF5QXNIVE1MKFxuICB0ZXh0QXJlYVRleHQsXG4gIHRlcm1NYXRjaEdsb3NzYXJ5LFxuICB0ZXJtTGlzdCxcbiAgc291cmNlQ2VsbCxcbiAgdGVybU1hdGNoR2xvc3NhcnlTb3VyY2UsXG4gIG9yaWdpbmFsVGVybUxpc3Rcbikge1xuICBsZXQgdGV4dFdpdGhHbG9zc2FyeSA9IHJlcGxhY2VUZXh0V2l0aEdsb3NzYXJ5KFxuICAgIHRleHRBcmVhVGV4dCxcbiAgICB0ZXJtTWF0Y2hHbG9zc2FyeSxcbiAgICB0ZXJtTGlzdCxcbiAgICBzb3VyY2VDZWxsLFxuICAgIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlLFxuICAgIG9yaWdpbmFsVGVybUxpc3RcbiAgKTtcblxuICBsZXQgdGV4dFdpdGhTcGFjZXNCZWZvcmVQdW5jdHVhdGlvblJlcGxhY2VkID0gdGV4dFdpdGhHbG9zc2FyeS5yZXBsYWNlKFxuICAgIC8gKyg/PVtcXC5cXCFcXD9dKS9nLFxuICAgIHJlcGxhY2VtZW50RnVuY3Rpb25cbiAgKTtcblxuICAvLyBiw7RpIMSRZW4gbmjhu69uZyBjaOG7lyBjw7MgaMahbiBoYWkgZOG6pXUgY8OhY2ggbGnhu4FuLlxuICBsZXQgdGV4dFdpdGhTcGFjZXNSZXBsYWNlZCA9IHRleHRXaXRoU3BhY2VzQmVmb3JlUHVuY3R1YXRpb25SZXBsYWNlZC5yZXBsYWNlKFxuICAgIC8oPzw9ICkgKy9nLFxuICAgIHJlcGxhY2VtZW50RnVuY3Rpb25cbiAgKTtcblxuICAvLyBraGkgbsOgbyBk4bqldSBjw6FjaCB0aOG7q2EgeHXhuqV0IGhp4buHbiBuZ2F5IHNhdSBk4bqldSAuID8gISwgbcOsbmggdGhheSB0aOG6vyBk4bqldSDijrUgxJHhuqd1IHRpw6puIGLhurFuZyAmbmJzcDsgxJHhu4MgY2hvIHBow6lwIHVzZXIgY8OzIGhhaSBk4bqldSBjw6FjaCBzYXUgLiA/ICEuXG4gIGNvbnN0IHJlZ2V4ID0gbmV3IFJlZ0V4cChcIig/PD1bLj8hXSkgXCIgKyByZXBsYWNlbWVudENvZGUsIFwiZ1wiKTtcbiAgbGV0IHRleHRBbGxvd2luZ0RvdWJsZVNwYWNlQWZ0ZXJFbmRPZlNlbnRlbmNlID1cbiAgICB0ZXh0V2l0aFNwYWNlc1JlcGxhY2VkLnJlcGxhY2UocmVnZXgsIFwiICZuYnNwO1wiKTtcblxuICAvLyB0aGF5IHRo4bq/IGPDoWMgZOG6pXUgY8OhY2ggdGjhu6thIGLhurFuZyBk4bqldSDijrUgbcOgdSBk4buPXG4gIGxldCB0ZXh0V2l0aFNwYWNlc0FzVW5kZXJzY29yZXMgPVxuICAgIHRleHRBbGxvd2luZ0RvdWJsZVNwYWNlQWZ0ZXJFbmRPZlNlbnRlbmNlLnJlcGxhY2VBbGwoXG4gICAgICByZXBsYWNlbWVudENvZGUsXG4gICAgICBcIjxmb250IGNvbG9yPSNGMDA+4o61PC9mb250PlwiXG4gICAgKTtcblxuICByZXR1cm4gdGV4dFdpdGhTcGFjZXNBc1VuZGVyc2NvcmVzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc29ydEdsb3NzYXJ5TGlzdChnbG9zc2FyeSkge1xuICBnbG9zc2FyeS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXJtLCBpKSB7XG4gICAgZ2xvc3NhcnlbaV0gPSB0ZXJtLnRvTG93ZXJDYXNlKCk7XG4gIH0pO1xuICByZXR1cm4gZ2xvc3Nhcnkuc29ydCgoYSwgYikgPT4gYi5sZW5ndGggLSBhLmxlbmd0aCk7XG59XG5cbi8qKlxuICogQSBjb21wbGV0ZSBtYXRjaCBvZiB0ZXJtIGluIHN0cmluZyBpcyB3aGVuIHRlcm0gbWF0Y2hlcyBhIGNvbXBsZXRlIHdvcmQgb3JcbiAqIHBocmFzZSBpbiBzdHJpbmcgYW5kIG5vIHBhcnRpYWwgd29yZHMgaW4gc3RyaW5nIGFyZSBsZWZ0IGhhbmdpbmcgb2ZmIHRoZVxuICogc3RhcnQgb3IgZW5kLiBGb3IgZXhhbXBsZSwgaWYgdGVybSBpcyBcImZ1bGxcIiBhbmQgc3RyaW5nIGlzIFwiYmVhdXRpZnVsbHlcIiwgdGhhdFxuICogaXMgbm90IGEgY29tcGxldGUgbWF0Y2ggYmVjYXVzZSBcImJlYXV0aVwiIGhhbmdzIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBcInlcIiBleHRlbmRzXG4gKiBiZWZvcmUgdGhlIHN0YXJ0IG9mIHRoZSBzZWN0aW9uIG9mIG1hdGNoaW5nIHRleHQuXG4gKiovXG5mdW5jdGlvbiBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhzdHJpbmcsIHN0YXJ0SW5kZXgsIHNlZ21lbnRlciwgdGVybSkge1xuICAvLyBpbml0aWFsaXplIHZhbHVlcyBmb3Igb3V0cHV0XG4gIC8vIHRoaXMgaXMgdGhlIG91dHB1dCBhcyBpdCBzaG91bGQgYmUgaWYgbm8gbWF0Y2ggaXMgZm91bmRcbiAgbGV0IG1hdGNoQm91bmRhcmllcyA9IHtcbiAgICBuYWl2ZU1hdGNoOiBmYWxzZSxcbiAgICBjb21wbGV0ZU1hdGNoOiBmYWxzZSxcbiAgICBuYWl2ZU1hdGNoU3RhcnQ6IC0xLFxuICAgIG5haXZlTWF0Y2hFbmQ6IC0xLFxuICAgIGNvbXBsZXRlTWF0Y2hTdGFydDogLTEsXG4gICAgY29tcGxldGVNYXRjaEVuZDogLTEsXG4gIH07XG5cbiAgLy8gZmluZCBhIG1hdGNoIGJ5IHNpbXBsZSBzdHJpbmcgc2VhcmNoLCBzdGFydGluZyBhdCBzdGFydEluZGV4LlxuICBsZXQgdW5zZWFyY2hlZFBhcnRPZlN0cmluZyA9IHN0cmluZy5zdWJzdHJpbmcoc3RhcnRJbmRleCk7XG4gIGxldCBtYXRjaEluZGV4ID0gdW5zZWFyY2hlZFBhcnRPZlN0cmluZy5pbmRleE9mKHRlcm0pICsgc3RhcnRJbmRleDtcblxuICAvLyBpZiBubyBzaW1wbGUgbWF0Y2ggd2FzIGZvdW5kLCByZXR1cm5cbiAgaWYgKG1hdGNoSW5kZXggPCBzdGFydEluZGV4KSByZXR1cm4gbWF0Y2hCb3VuZGFyaWVzO1xuXG4gIC8vIGlmIHdlIHJlYWNoIHRoaXMgcG9pbnQgdGhlbiBhIG5haXZlIG1hdGNoIHdhcyBmb3VuZC5cbiAgLy8gdXBkYXRlIG5haXZlIG1hdGNoIGJvdW5kYXJ5IGluZm9ybWF0aW9uIGFjY29yZGluZ2x5LlxuICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaCA9IHRydWU7XG4gIG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoU3RhcnQgPSBtYXRjaEluZGV4O1xuICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaEVuZCA9IG1hdGNoSW5kZXggKyB0ZXJtLmxlbmd0aCAtIDE7XG5cbiAgLy8gc2VnbWVudCB0aGUgc3RyaW5nXG4gIGxldCBzdHJpbmdTZWdtZW50cyA9IHNlZ21lbnRlci5zZWdtZW50KHN0cmluZyk7XG5cbiAgLy8gZ2V0IHRoZSBzdHJpbmcgc2VnbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBtYXRjaCBpbmRleC5cbiAgLy8gdGhpcyBpcyB0aGUgZmlyc3Qgd29yZCBpbiBzdHJpbmcgdGhhdCBtYXRjaGVzIHRlcm1cbiAgbGV0IGZpcnN0TWF0Y2hpbmdTZWdtZW50ID0gc3RyaW5nU2VnbWVudHMuY29udGFpbmluZyhtYXRjaEluZGV4KTtcblxuICAvLyBpZiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIHNlZ21lbnQgZG9lc24ndCBtYXRjaCB0aGUgbWF0Y2hJbmRleCBmb3VuZFxuICAvLyBieSBuYWl2ZSBzZWFyY2gsIGl0J3MgYSBwYXJ0aWFsIG1hdGNoLiBSZXR1cm4gdGhlIGJvdW5kYXJ5IGluZm8gYXMtaXNcbiAgLy8gd2l0aG91dCBjb21wbGV0ZSBtYXRjaCBkYXRhLlxuICBpZiAoZmlyc3RNYXRjaGluZ1NlZ21lbnQuaW5kZXggPCBtYXRjaEluZGV4KSByZXR1cm4gbWF0Y2hCb3VuZGFyaWVzO1xuXG4gIC8qKlxuICAgKiBhdCB0aGlzIHBvaW50IHdlIGtub3cgdGhhdCB0aGUgZmlyc3QgY2hhcmFjdGVyIGluIFwidGVybVwiIGlzIHRoZSBmaXJzdFxuICAgKiBjaGFyYWN0ZXIgb2YgYSBzZWdtZW50IGluIHN0cmluZy4gbm93IHdlIG5lZWQgdG8gY2hlY2sgaWYgdGhlIGxhc3QgY2hhcmFjdGVyXG4gICAqIGluIFwidGVybVwiIGlzIGFsc28gYWxpZ25lZCB3aXRoIHRoZSBsYXN0IGNoYXJhY3RlciBvZiBhIHNlZ21lbnQgaW4gc3RyaW5nLlxuICAgKiovXG5cbiAgLy8gZ2V0IHRoZSBzdHJpbmcgc2VnbWVudCB0aGF0IGNvbnRhaW5zIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0ZXJtXG4gIGxldCBsYXN0TWF0Y2hpbmdTZWdtZW50ID0gc3RyaW5nU2VnbWVudHMuY29udGFpbmluZyhcbiAgICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaEVuZFxuICApO1xuXG4gIC8vIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRoYXQgc3RyaW5nIHNlZ21lbnRcbiAgbGV0IGVuZE9mTGFzdE1hdGNoaW5nU2VnbWVudCA9XG4gICAgbGFzdE1hdGNoaW5nU2VnbWVudC5pbmRleCArIGxhc3RNYXRjaGluZ1NlZ21lbnQuc2VnbWVudC5sZW5ndGggLSAxO1xuXG4gIC8vIGlmIHRoZSBlbmQgb2YgdGhlIGxhc3QgbWF0Y2hpbmcgc2VnbWVudCBtYXRjaGVzIHdpdGggdGhlIGVuZCBvZiB0aGUgbmFpdmUgXCJpbmRleE9mXCJcbiAgLy8gbWF0Y2ggdGhlbiB0aGUgbWF0Y2ggaXMgYSBjb21wbGV0ZSBtYXRjaCB3aXRoIG5vIGV4dHJhIHdvcmQgY2hhcmFjdGVycyBoYW5naW5nXG4gIC8vIG9mZiB0aGUgc3RhcnQgb3IgZW5kLlxuICBpZiAoZW5kT2ZMYXN0TWF0Y2hpbmdTZWdtZW50ID09IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoRW5kKSB7XG4gICAgLy8gdXBkYXRlIHRoZSBjb21wbGV0ZSBtYXRjaCBib3VuZGFyeSBpbmZvXG4gICAgbWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2ggPSB0cnVlO1xuICAgIG1hdGNoQm91bmRhcmllcy5jb21wbGV0ZU1hdGNoU3RhcnQgPSBmaXJzdE1hdGNoaW5nU2VnbWVudC5pbmRleDtcbiAgICBtYXRjaEJvdW5kYXJpZXMuY29tcGxldGVNYXRjaEVuZCA9IGVuZE9mTGFzdE1hdGNoaW5nU2VnbWVudDtcbiAgfVxuXG4gIHJldHVybiBtYXRjaEJvdW5kYXJpZXM7XG59XG5cbi8qKlxuICogU2VhcmNoZXMgXCJzdHJpbmdcIiBmb3IgdGVybXMgaW4gXCJnbG9zc2FyeVwiIGFuZCBnaXZlcyB0aGUgbG9jYXRpb24gd2hlcmUgZWFjaCB0ZXJtIGFwcGVhcnMuIElmIHNldmVyYWwgZ2xvc3NhcnkgdGVybXMgb3ZlcmxhcCwgbWF0Y2hpbmcgb24gdGhlIHNhbWUgd29yZHMgdGhlbiB0aGUgbG9uZ2VzdCB0ZXJtIHRha2VzIHByZWNlZGVuY2UuXG4gKlxuICogQHBhcmFtIHN0cmluZyAtIHRoZSB0ZXh0IHN0cmluZyBpbiB3aGljaCB3ZSB3YW50IHRvIHNlYXJjaCBmb3IgZ2xvc3NhcnkgdGVybXNcbiAqIEBwYXJhbSBnbG9zc2FyeSAtIGFuIGFycmF5IG9mIHRleHQgc3RyaW5ncywgYWxsIHRoZSB0ZXJtcyBpbiB0aGUgZ2xvc3NhcnkuIFRoaXMgbGlzdCBtYXkgY29udGFpbiBzZXZlcmFsIHRob3VzYW5kIGl0ZW1zLlxuICogQHBhcmFtIGxhbmd1YWdlQ29kZSAtIElTTyA2MzktMSBsYW5ndWFnZSBjb2RlXG4gKiBAcmV0dXJucyB7YXJyYXl9IC0gYSBsaXN0IG9mIHBhaXJzIFtpbmRleCwgdGVybV0gd2hlcmUgaW50IGlzIHRoZSBpbmRleCBhdCB3aGljaCB0ZXJtIGFwcGVhcnMgaW4gc3RyaW5nLlxuICoqL1xuZnVuY3Rpb24gZ2xvc3NhcnlNYXRjaGVzKFxuICBzdHJpbmcsXG4gIGFsbEdsb3NzYXJ5LFxuICBjYXNlU2Vuc2l0aXZlID0gZmFsc2UsXG4gIHRleHRJbmZvLFxuICBvcmlnaW5hbFRlcm1MaXN0XG4pIHtcbiAgLy8gbWFrZSBhIGNvcHkgb2Ygc3RyaW5nIHNvIHRoYXQgdGhlIG9yaWdpbmFsIGlzIG5vdCBsb3N0IHdoZW4gd2UgbW9kaWZ5IGl0XG4gIGxldCBzdHJpbmdDb3B5ID0gc3RyaW5nO1xuICAvLyBpZiB0aGUgc2VhcmNoIGlzIG5vdCBjYXNlLXNlbnNpdGl2ZSwgY29udmVydCBldmVyeXRoaW5nIHRvIGxvd2VyIGNhc2VcbiAgaWYgKCFjYXNlU2Vuc2l0aXZlKSB7XG4gICAgc3RyaW5nID0gc3RyaW5nLnRvTG93ZXJDYXNlKCk7XG4gIH1cblxuICAvLyBzcGxpdCB0aGUgc3RyaW5nIGludG8gc2VnbWVudHMsIHNlcGFyYXRpbmcgYnkgd29yZFxuICBsZXQgc2VnbWVudGVyID0gbmV3IEludGwuU2VnbWVudGVyKHRleHRJbmZvLmxhbmd1YWdlLCB7XG4gICAgZ3JhbnVsYXJpdHk6IFwid29yZFwiLFxuICB9KTtcblxuICBsZXQgb3V0cHV0ID0gQXJyYXkoMCk7XG5cbiAgLy8gZm9yIGVhY2ggbGlzdCBvZiB0ZXJtcyBpbiB0aGUgc29ydGVkIGdsb3NzYXJ5XG4gIGFsbEdsb3NzYXJ5Py5zcmNHbG9zc2FyeS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgLy8gd2Ugc3RhcnQgc2VhcmNoaW5nIGZvciBcInRlcm1cIiBzdGFydGluZyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgXCJzdHJpbmdcIlxuICAgIGxldCBzZWFyY2hTdGFydEluZGV4ID0gMDtcblxuICAgIC8vIGZpbmQgdGhlIGxvY2F0aW9uIGluIFwic3RyaW5nXCIgd2hlcmUgdGhlIFwidGVybVwiIGlzIGZvdW5kXG4gICAgbGV0IG1hdGNoQm91bmRhcmllcyA9IGNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzKFxuICAgICAgc3RyaW5nLFxuICAgICAgc2VhcmNoU3RhcnRJbmRleCxcbiAgICAgIHNlZ21lbnRlcixcbiAgICAgIHRlcm1cbiAgICApO1xuXG4gICAgLy8gaWYgXCJ0ZXJtXCIgd2FzIGZvdW5kIGluIFwic3RyaW5nXCIgYnkgbmFpdmUgaW5kZXhPZiBzZWFyY2hcbiAgICB3aGlsZSAoXG4gICAgICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaCAmJlxuICAgICAgdGV4dEluZm8ubGFuZ3VhZ2UgPT09IG9yaWdpbmFsVGVybUxpc3RbMF0uc291cmNlTGFuZ3VhZ2VcbiAgICApIHtcbiAgICAgIC8vIHNpbmNlIGEgbmFpdmUgbWF0Y2ggd2FzIGZvdW5kLCB3ZSB1cGRhdGUgdGhlIHNlYXJjaFN0YXJ0SW5kZXggdG8gcHJldmVudFxuICAgICAgLy8gZmluZGluZyB0aGF0IHNhbWUgbmFpdmUgbWF0Y2ggYWdhaW4gaW4gdGhlIGZ1dHVyZS5cbiAgICAgIHNlYXJjaFN0YXJ0SW5kZXggPSBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaEVuZCArIDE7XG5cbiAgICAgIC8vIGlmIHRoZSBtYXRjaCBpcyBhIGNvbXBsZXRlIG1hdGNoLCByZWNvcmQgaXQsIHRoZW4gZXJhc2UgaXQgZnJvbSBzdHJpbmcgdG9cbiAgICAgIC8vIHByZXZlbnQgc2hvcnRlciB0ZXJtcyBmcm9tIGRvdWJsZS1tYXRjaGluZyBvbiBpdCBsYXRlciBvbi5cbiAgICAgIGlmIChtYXRjaEJvdW5kYXJpZXMuY29tcGxldGVNYXRjaCkge1xuICAgICAgICAvLyBnZXQgYSBzaG9ydGVyIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRleCB3aGVyZSB0aGUgbmFpdmUgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgIGxldCBtYXRjaEluZGV4ID0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hTdGFydDtcblxuICAgICAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHRlcm0gZnJvbSB0aGUgY29weSBvZiBzdHJpbmcsIGluIGNhc2UgdGhlIGNhc2UtaW5zZW50aXRpdmVcbiAgICAgICAgLy8gc2VhcmNoIGNhdXNlZCB0aGUgc3RyaW5nIHRvIGJlIG1vZGlmaWVkXG4gICAgICAgIGxldCBvcmlnaW5hbFRlcm0gPSBzdHJpbmdDb3B5LnN1YnN0cmluZyhcbiAgICAgICAgICBtYXRjaEluZGV4LFxuICAgICAgICAgIG1hdGNoSW5kZXggKyB0ZXJtLmxlbmd0aFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgdGVybSB0byB0aGUgb3V0cHV0IGxpc3RcbiAgICAgICAgb3V0cHV0LnB1c2goW21hdGNoSW5kZXgsIG9yaWdpbmFsVGVybV0pO1xuXG4gICAgICAgIC8vIEVyYXNlIHRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMgaW4gc3RyaW5nIHNvIHRoYXQgc3Vic2VxdWVudFxuICAgICAgICAvLyB0ZXJtcyBpbiB0aGUgZ2xvc3NhcnkgY2FuJ3QgbWF0Y2ggd2l0aCB0aGUgc2FtZSB0ZXh0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBCZWNhdXNlIG91ciBnbG9zc2FyeSBpcyBzb3J0ZWQgd2l0aCBsb25nZXN0IHRlcm1zIGZpcnN0LFxuICAgICAgICAvLyB0aGlzIGVuc3VyZXMgdGhhdCBsb25nZXIgbWF0Y2hlcyB0YWtlIHByZWNlbmRlbmNlIG92ZXIgc2hvcnRlclxuICAgICAgICAvLyBvbmVzLlxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSh0ZXJtLCBcIiBcIi5yZXBlYXQodGVybS5sZW5ndGgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBvdGhlciBwbGFjZXMgaW4gXCJzdHJpbmdcIiB0aGF0IG1hdGNoIFwidGVybVwiLlxuICAgICAgLy8gSWYgdGhlcmUgYXJlLCB0aGUgd2hpbGUgbG9vcCB3aWxsIHJlcGVhdC5cbiAgICAgIG1hdGNoQm91bmRhcmllcyA9IGNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzKFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIHNlYXJjaFN0YXJ0SW5kZXgsXG4gICAgICAgIHNlZ21lbnRlcixcbiAgICAgICAgdGVybVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIGFsbEdsb3NzYXJ5Py50YXJnZXRHbG9zc2FyeS5mb3JFYWNoKGZ1bmN0aW9uICh0ZXJtKSB7XG4gICAgLy8gd2Ugc3RhcnQgc2VhcmNoaW5nIGZvciBcInRlcm1cIiBzdGFydGluZyBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgXCJzdHJpbmdcIlxuICAgIGxldCBzZWFyY2hTdGFydEluZGV4ID0gMDtcblxuICAgIC8vIGZpbmQgdGhlIGxvY2F0aW9uIGluIFwic3RyaW5nXCIgd2hlcmUgdGhlIFwidGVybVwiIGlzIGZvdW5kXG4gICAgbGV0IG1hdGNoQm91bmRhcmllcyA9IGNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzKFxuICAgICAgc3RyaW5nLFxuICAgICAgc2VhcmNoU3RhcnRJbmRleCxcbiAgICAgIHNlZ21lbnRlcixcbiAgICAgIHRlcm1cbiAgICApO1xuXG4gICAgLy8gaWYgXCJ0ZXJtXCIgd2FzIGZvdW5kIGluIFwic3RyaW5nXCIgYnkgbmFpdmUgaW5kZXhPZiBzZWFyY2hcbiAgICB3aGlsZSAoXG4gICAgICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaCAmJlxuICAgICAgdGV4dEluZm8ubGFuZ3VhZ2UgPT09IG9yaWdpbmFsVGVybUxpc3RbMF0udGFyZ2V0TGFuZ3VhZ2VcbiAgICApIHtcbiAgICAgIC8vIHNpbmNlIGEgbmFpdmUgbWF0Y2ggd2FzIGZvdW5kLCB3ZSB1cGRhdGUgdGhlIHNlYXJjaFN0YXJ0SW5kZXggdG8gcHJldmVudFxuICAgICAgLy8gZmluZGluZyB0aGF0IHNhbWUgbmFpdmUgbWF0Y2ggYWdhaW4gaW4gdGhlIGZ1dHVyZS5cbiAgICAgIHNlYXJjaFN0YXJ0SW5kZXggPSBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaEVuZCArIDE7XG5cbiAgICAgIC8vIGlmIHRoZSBtYXRjaCBpcyBhIGNvbXBsZXRlIG1hdGNoLCByZWNvcmQgaXQsIHRoZW4gZXJhc2UgaXQgZnJvbSBzdHJpbmcgdG9cbiAgICAgIC8vIHByZXZlbnQgc2hvcnRlciB0ZXJtcyBmcm9tIGRvdWJsZS1tYXRjaGluZyBvbiBpdCBsYXRlciBvbi5cbiAgICAgIGlmIChtYXRjaEJvdW5kYXJpZXMuY29tcGxldGVNYXRjaCkge1xuICAgICAgICAvLyBnZXQgYSBzaG9ydGVyIHZhcmlhYmxlIG5hbWUgZm9yIHRoZSBpbmRleCB3aGVyZSB0aGUgbmFpdmUgbWF0Y2ggd2FzIGZvdW5kXG4gICAgICAgIGxldCBtYXRjaEluZGV4ID0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hTdGFydDtcblxuICAgICAgICAvLyBnZXQgdGhlIG9yaWdpbmFsIHRlcm0gZnJvbSB0aGUgY29weSBvZiBzdHJpbmcsIGluIGNhc2UgdGhlIGNhc2UtaW5zZW50aXRpdmVcbiAgICAgICAgLy8gc2VhcmNoIGNhdXNlZCB0aGUgc3RyaW5nIHRvIGJlIG1vZGlmaWVkXG4gICAgICAgIGxldCBvcmlnaW5hbFRlcm0gPSBzdHJpbmdDb3B5LnN1YnN0cmluZyhcbiAgICAgICAgICBtYXRjaEluZGV4LFxuICAgICAgICAgIG1hdGNoSW5kZXggKyB0ZXJtLmxlbmd0aFxuICAgICAgICApO1xuXG4gICAgICAgIC8vIGFkZCB0aGUgdGVybSB0byB0aGUgb3V0cHV0IGxpc3RcbiAgICAgICAgb3V0cHV0LnB1c2goW21hdGNoSW5kZXgsIG9yaWdpbmFsVGVybV0pO1xuXG4gICAgICAgIC8vIEVyYXNlIHRoZSBjb3JyZXNwb25kaW5nIGNoYXJhY3RlcnMgaW4gc3RyaW5nIHNvIHRoYXQgc3Vic2VxdWVudFxuICAgICAgICAvLyB0ZXJtcyBpbiB0aGUgZ2xvc3NhcnkgY2FuJ3QgbWF0Y2ggd2l0aCB0aGUgc2FtZSB0ZXh0LlxuICAgICAgICAvL1xuICAgICAgICAvLyBCZWNhdXNlIG91ciBnbG9zc2FyeSBpcyBzb3J0ZWQgd2l0aCBsb25nZXN0IHRlcm1zIGZpcnN0LFxuICAgICAgICAvLyB0aGlzIGVuc3VyZXMgdGhhdCBsb25nZXIgbWF0Y2hlcyB0YWtlIHByZWNlbmRlbmNlIG92ZXIgc2hvcnRlclxuICAgICAgICAvLyBvbmVzLlxuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZSh0ZXJtLCBcIiBcIi5yZXBlYXQodGVybS5sZW5ndGgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gY2hlY2sgdG8gc2VlIGlmIHRoZXJlIGFyZSBvdGhlciBwbGFjZXMgaW4gXCJzdHJpbmdcIiB0aGF0IG1hdGNoIFwidGVybVwiLlxuICAgICAgLy8gSWYgdGhlcmUgYXJlLCB0aGUgd2hpbGUgbG9vcCB3aWxsIHJlcGVhdC5cbiAgICAgIG1hdGNoQm91bmRhcmllcyA9IGNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzKFxuICAgICAgICBzdHJpbmcsXG4gICAgICAgIHNlYXJjaFN0YXJ0SW5kZXgsXG4gICAgICAgIHNlZ21lbnRlcixcbiAgICAgICAgdGVybVxuICAgICAgKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHNvcnQgdGhlIG91dHB1dCBieSB0aGUgaW5kaWNlcyBhbmQgcmV0dXJuXG4gIHJldHVybiBvdXRwdXQuc29ydCgoYSwgYikgPT4gYVswXSAtIGJbMF0pO1xufVxuXG5leHBvcnQgY29uc3QgZGV0ZWN0R2xvc3NhcnlTb3VyY2UgPSAoXG4gIHNvdXJjZSxcbiAgZ2xvc3NhcnksXG4gIHRleHRJbmZvLFxuICBvcmlnaW5hbFRlcm1MaXN0XG4pID0+IHtcbiAgbGV0IGNhc2VTZW5zaXRpdmUgPSBmYWxzZTtcblxuICBpZiAoc291cmNlPy52YWx1ZSkge1xuICAgIHJldHVybiBnbG9zc2FyeU1hdGNoZXMoXG4gICAgICBzb3VyY2U/LnZhbHVlLFxuICAgICAgZ2xvc3NhcnksXG4gICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgdGV4dEluZm8sXG4gICAgICBvcmlnaW5hbFRlcm1MaXN0XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG5cbmV4cG9ydCBjb25zdCBkZXRlY3RHbG9zc2FyeSA9IChcbiAgdGV4dCxcbiAgZ2xvc3NhcnksXG4gIHRleHRJbmZvLFxuICBvcmlnaW5hbFRlcm1MaXN0LFxuICBzb3VyY2VcbikgPT4ge1xuICBsZXQgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlO1xuXG4gIGlmICh0ZXh0KSB7XG4gICAgcmV0dXJuIGdsb3NzYXJ5TWF0Y2hlcyhcbiAgICAgIHRleHQsXG4gICAgICBnbG9zc2FyeSxcbiAgICAgIGNhc2VTZW5zaXRpdmUsXG4gICAgICB0ZXh0SW5mbyxcbiAgICAgIG9yaWdpbmFsVGVybUxpc3RcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJyZXBsYWNlVGV4dEF0SW5kZXgiLCJyZW5kZXJUb1N0cmluZyIsInJlcGxhY2VtZW50Q29kZSIsInJlcGxhY2VtZW50RnVuY3Rpb24iLCJtIiwicmVwZWF0IiwibGVuZ3RoIiwicmVwbGFjZVRleHRXaXRoR2xvc3NhcnkiLCJ0ZXh0IiwidGVybU1hdGNoR2xvc3NhcnkiLCJ0ZXJtTGlzdCIsInNvdXJjZUNlbGwiLCJnbG9zc2FyeSIsIm9yaWdpbmFsVGVybUxpc3QiLCJuZXdUZXh0IiwiaW5jcmVhc2VkVG9vbHRpcCIsInRlcm1NYXRjaEdsb3NzYXJ5U291cmNlIiwiZGV0ZWN0R2xvc3NhcnlTb3VyY2UiLCJjb25zb2xlIiwibG9nIiwiZm9yRWFjaCIsImkiLCJ0ZXJtTWF0Y2giLCJ0cmFubGF0aW9uT2ZUZXJtIiwic291cmNlT2ZUZXJtIiwidGVybU5vdGUiLCJzb3VyY2VUZXJtQXBwZWFyIiwidGVybSIsInNvdXJjZVZhbHVlcyIsInNvbWUiLCJ2YWx1ZSIsInRvTG93ZXJDYXNlIiwidHJhbnNsYXRpb25zIiwibm90ZSIsInZhbHVlMiIsInZhbHVlMSIsIl8iLCJ0b29sdGlwQ29udGVudCIsInNwYW4iLCJjbGFzc05hbWUiLCJiIiwiZGl2Iiwiam9pbiIsImRpc3BsYXlBc0hUTUwiLCJ0ZXh0QXJlYVRleHQiLCJ0ZXh0V2l0aEdsb3NzYXJ5IiwidGV4dFdpdGhTcGFjZXNCZWZvcmVQdW5jdHVhdGlvblJlcGxhY2VkIiwicmVwbGFjZSIsInRleHRXaXRoU3BhY2VzUmVwbGFjZWQiLCJyZWdleCIsIlJlZ0V4cCIsInRleHRBbGxvd2luZ0RvdWJsZVNwYWNlQWZ0ZXJFbmRPZlNlbnRlbmNlIiwidGV4dFdpdGhTcGFjZXNBc1VuZGVyc2NvcmVzIiwicmVwbGFjZUFsbCIsInNvcnRHbG9zc2FyeUxpc3QiLCJzb3J0IiwiYSIsImNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzIiwic3RyaW5nIiwic3RhcnRJbmRleCIsInNlZ21lbnRlciIsIm1hdGNoQm91bmRhcmllcyIsIm5haXZlTWF0Y2giLCJjb21wbGV0ZU1hdGNoIiwibmFpdmVNYXRjaFN0YXJ0IiwibmFpdmVNYXRjaEVuZCIsImNvbXBsZXRlTWF0Y2hTdGFydCIsImNvbXBsZXRlTWF0Y2hFbmQiLCJ1bnNlYXJjaGVkUGFydE9mU3RyaW5nIiwic3Vic3RyaW5nIiwibWF0Y2hJbmRleCIsImluZGV4T2YiLCJzdHJpbmdTZWdtZW50cyIsInNlZ21lbnQiLCJmaXJzdE1hdGNoaW5nU2VnbWVudCIsImNvbnRhaW5pbmciLCJpbmRleCIsImxhc3RNYXRjaGluZ1NlZ21lbnQiLCJlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQiLCJnbG9zc2FyeU1hdGNoZXMiLCJhbGxHbG9zc2FyeSIsImNhc2VTZW5zaXRpdmUiLCJ0ZXh0SW5mbyIsInN0cmluZ0NvcHkiLCJJbnRsIiwiU2VnbWVudGVyIiwibGFuZ3VhZ2UiLCJncmFudWxhcml0eSIsIm91dHB1dCIsIkFycmF5Iiwic3JjR2xvc3NhcnkiLCJzZWFyY2hTdGFydEluZGV4Iiwic291cmNlTGFuZ3VhZ2UiLCJvcmlnaW5hbFRlcm0iLCJwdXNoIiwidGFyZ2V0R2xvc3NhcnkiLCJ0YXJnZXRMYW5ndWFnZSIsInNvdXJjZSIsImRldGVjdEdsb3NzYXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/glossaryUtils.js\n"));

/***/ })

});
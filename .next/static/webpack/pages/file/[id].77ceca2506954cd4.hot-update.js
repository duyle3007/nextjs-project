"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/file/[id]",{

/***/ "./utils/glossaryUtils.js":
/*!********************************!*\
  !*** ./utils/glossaryUtils.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"detectGlossary\": function() { return /* binding */ detectGlossary; },\n/* harmony export */   \"displayAsHTML\": function() { return /* binding */ displayAsHTML; },\n/* harmony export */   \"sortGlossaryList\": function() { return /* binding */ sortGlossaryList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./utils/utils.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/server */ \"./node_modules/react-dom/server.browser.js\");\n\n\n\nconst replacementCode = \"XxcD5JZ73PDgM4PBDWYtfKMKAakSuRsG\";\nfunction replacementFunction(m) {\n    return replacementCode.repeat(m.length);\n}\nconst replaceTextWithGlossary = (text, termMatchGlossary, termList, sourceCell, termSourceMatchGlossary)=>{\n    let newText = text;\n    let increasedTooltip = 0;\n    termMatchGlossary.forEach((param)=>{\n        let [i, termMatch] = param;\n        let tranlationOfTerm, sourceOfTerm, termNote;\n        let sourceTermAppear = false;\n        for (const term of termList){\n            if (term.sourceValues.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                tranlationOfTerm = term.translations;\n                termNote = term.note;\n                break;\n            } else if (term.translations.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                sourceOfTerm = term.sourceValues;\n                termNote = term.note;\n                break;\n            }\n        }\n        sourceTermAppear = sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.some((value2)=>{\n            return termSourceMatchGlossary === null || termSourceMatchGlossary === void 0 ? void 0 : termSourceMatchGlossary.some((param)=>{\n                let [_, value1] = param;\n                return value1.toLowerCase() === value2.toLowerCase();\n            });\n        });\n        const tooltipContent = (0,react_dom_server__WEBPACK_IMPORTED_MODULE_2__.renderToString)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            className: \"glossary-tooltip\",\n            children: [\n                termMatch,\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"tooltip\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: termMatch\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 54,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"translateValue\",\n                            children: sourceOfTerm ? sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.join(\", \") : tranlationOfTerm === null || tranlationOfTerm === void 0 ? void 0 : tranlationOfTerm.join(\", \")\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 55,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"note\",\n                            children: termNote\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 60,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                    lineNumber: 53,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n            lineNumber: 51,\n            columnNumber: 7\n        }, undefined));\n        if (sourceOfTerm && sourceTermAppear || !sourceOfTerm) {\n            newText = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.replaceTextAtIndex)(newText, i + increasedTooltip, termMatch.length, tooltipContent);\n            increasedTooltip = increasedTooltip + tooltipContent.length - termMatch.length;\n        }\n    });\n    return newText;\n};\nfunction displayAsHTML(textAreaText, termMatchGlossary, termList, sourceCell, termSourceMatchGlossary) {\n    let textWithGlossary = replaceTextWithGlossary(textAreaText, termMatchGlossary, termList, sourceCell, termSourceMatchGlossary);\n    let textWithSpacesBeforePunctuationReplaced = textWithGlossary.replace(/ +(?=[\\.\\!\\?])/g, replacementFunction);\n    // bôi đen những chỗ có hơn hai dấu cách liền.\n    let textWithSpacesReplaced = textWithSpacesBeforePunctuationReplaced.replace(RegExp(\"(?<= ) +\", \"g\"), replacementFunction);\n    // khi nào dấu cách thừa xuất hiện ngay sau dấu . ? !, mình thay thế dấu ⎵ đầu tiên bằng &nbsp; để cho phép user có hai dấu cách sau . ? !.\n    const regex = new RegExp(\"(?<=[.?!]) \" + replacementCode, \"g\");\n    let textAllowingDoubleSpaceAfterEndOfSentence = textWithSpacesReplaced.replace(regex, \" &nbsp;\");\n    // thay thế các dấu cách thừa bằng dấu ⎵ màu dỏ\n    let textWithSpacesAsUnderscores = textAllowingDoubleSpaceAfterEndOfSentence.replaceAll(replacementCode, \"<font color=#F00>⎵</font>\");\n    return textWithSpacesAsUnderscores;\n}\nfunction sortGlossaryList(glossary) {\n    glossary.forEach(function(term, i) {\n        glossary[i] = term.toLowerCase();\n    });\n    return glossary.sort((a, b)=>b.length - a.length);\n}\n/**\n * A complete match of term in string is when term matches a complete word or\n * phrase in string and no partial words in string are left hanging off the\n * start or end. For example, if term is \"full\" and string is \"beautifully\", that\n * is not a complete match because \"beauti\" hangs off the beginning and \"y\" extends\n * before the start of the section of matching text.\n **/ function completeMatchBoundaries(string, startIndex, segmenter, term) {\n    // initialize values for output\n    // this is the output as it should be if no match is found\n    let matchBoundaries = {\n        naiveMatch: false,\n        completeMatch: false,\n        naiveMatchStart: -1,\n        naiveMatchEnd: -1,\n        completeMatchStart: -1,\n        completeMatchEnd: -1\n    };\n    // find a match by simple string search, starting at startIndex.\n    let unsearchedPartOfString = string.substring(startIndex);\n    let matchIndex = unsearchedPartOfString.indexOf(term) + startIndex;\n    // if no simple match was found, return\n    if (matchIndex < startIndex) return matchBoundaries;\n    // if we reach this point then a naive match was found.\n    // update naive match boundary information accordingly.\n    matchBoundaries.naiveMatch = true;\n    matchBoundaries.naiveMatchStart = matchIndex;\n    matchBoundaries.naiveMatchEnd = matchIndex + term.length - 1;\n    // segment the string\n    let stringSegments = segmenter.segment(string);\n    // get the string segment that contains the match index.\n    // this is the first word in string that matches term\n    let firstMatchingSegment = stringSegments.containing(matchIndex);\n    // if the index of the matching segment doesn't match the matchIndex found\n    // by naive search, it's a partial match. Return the boundary info as-is\n    // without complete match data.\n    if (firstMatchingSegment.index < matchIndex) return matchBoundaries;\n    /**\n   * at this point we know that the first character in \"term\" is the first\n   * character of a segment in string. now we need to check if the last character\n   * in \"term\" is also aligned with the last character of a segment in string.\n   **/ // get the string segment that contains the last character of term\n    let lastMatchingSegment = stringSegments.containing(matchBoundaries.naiveMatchEnd);\n    // get the index of the last character of that string segment\n    let endOfLastMatchingSegment = lastMatchingSegment.index + lastMatchingSegment.segment.length - 1;\n    // if the end of the last matching segment matches with the end of the naive \"indexOf\"\n    // match then the match is a complete match with no extra word characters hanging\n    // off the start or end.\n    if (endOfLastMatchingSegment == matchBoundaries.naiveMatchEnd) {\n        // update the complete match boundary info\n        matchBoundaries.completeMatch = true;\n        matchBoundaries.completeMatchStart = firstMatchingSegment.index;\n        matchBoundaries.completeMatchEnd = endOfLastMatchingSegment;\n    }\n    return matchBoundaries;\n}\n/**\n * Searches \"string\" for terms in \"glossary\" and gives the location where each term appears. If several glossary terms overlap, matching on the same words then the longest term takes precedence.\n *\n * @param string - the text string in which we want to search for glossary terms\n * @param glossary - an array of text strings, all the terms in the glossary. This list may contain several thousand items.\n * @param languageCode - ISO 639-1 language code\n * @returns {array} - a list of pairs [index, term] where int is the index at which term appears in string.\n **/ function glossaryMatches(string, allGlossary) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, textInfo = arguments.length > 3 ? arguments[3] : void 0, originalTermList = arguments.length > 4 ? arguments[4] : void 0;\n    // make a copy of string so that the original is not lost when we modify it\n    let stringCopy = string;\n    // if the search is not case-sensitive, convert everything to lower case\n    if (!caseSensitive) {\n        string = string.toLowerCase();\n    }\n    // split the string into segments, separating by word\n    let segmenter = new Intl.Segmenter(textInfo.language, {\n        granularity: \"word\"\n    });\n    let output = Array(0);\n    // for each list of terms in the sorted glossary\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.srcGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].sourceLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.targetGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].targetLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    // sort the output by the indices and return\n    return output.sort((a, b)=>a[0] - b[0]);\n}\nconst detectGlossary = (text, glossary, textInfo, originalTermList)=>{\n    let caseSensitive = false;\n    if (text) {\n        return glossaryMatches(text, glossary, caseSensitive, textInfo, originalTermList);\n    } else {\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi91dGlscy9nbG9zc2FyeVV0aWxzLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTZDO0FBQ0s7QUFFbEQsTUFBTUUsa0JBQWtCO0FBRXhCLFNBQVNDLG9CQUFvQkMsQ0FBQyxFQUFFO0lBQzlCLE9BQU9GLGdCQUFnQkcsTUFBTSxDQUFDRCxFQUFFRSxNQUFNO0FBQ3hDO0FBRUEsTUFBTUMsMEJBQTBCLENBQzlCQyxNQUNBQyxtQkFDQUMsVUFDQUMsWUFDQUMsMEJBQ0c7SUFDSCxJQUFJQyxVQUFVTDtJQUNkLElBQUlNLG1CQUFtQjtJQUV2Qkwsa0JBQWtCTSxPQUFPLENBQUMsU0FBb0I7WUFBbkIsQ0FBQ0MsR0FBR0MsVUFBVTtRQUN2QyxJQUFJQyxrQkFBa0JDLGNBQWNDO1FBQ3BDLElBQUlDLG1CQUFtQixLQUFLO1FBRTVCLEtBQUssTUFBTUMsUUFBUVosU0FBVTtZQUMzQixJQUNFWSxLQUFLQyxZQUFZLENBQUNDLElBQUksQ0FDcEIsQ0FBQ0MsUUFBVUEsTUFBTUMsV0FBVyxPQUFPVCxVQUFVUyxXQUFXLEtBRTFEO2dCQUNBUixtQkFBbUJJLEtBQUtLLFlBQVk7Z0JBQ3BDUCxXQUFXRSxLQUFLTSxJQUFJO2dCQUNwQixLQUFNO1lBQ1IsT0FBTyxJQUNMTixLQUFLSyxZQUFZLENBQUNILElBQUksQ0FDcEIsQ0FBQ0MsUUFBVUEsTUFBTUMsV0FBVyxPQUFPVCxVQUFVUyxXQUFXLEtBRTFEO2dCQUNBUCxlQUFlRyxLQUFLQyxZQUFZO2dCQUNoQ0gsV0FBV0UsS0FBS00sSUFBSTtnQkFDcEIsS0FBTTtZQUNSLENBQUM7UUFDSDtRQUVBUCxtQkFBbUJGLHlCQUFBQSwwQkFBQUEsS0FBQUEsSUFBQUEsYUFBY0ssSUFBSSxDQUFDLENBQUNLO1lBQ3JDakIsT0FBQUEsb0NBQUFBLHFDQUFBQSxLQUFBQSxJQUFBQSx3QkFBeUJZLElBQUksQ0FDM0IsU0FBaUJNO29CQUFoQixDQUFDQyxHQUFHRCxPQUFPO3VCQUFLQSxPQUFPSixXQUFXLE9BQU9HLE9BQU9ILFdBQVc7WUFBQzs7UUFJakUsTUFBTU0saUJBQWlCL0IsZ0VBQWNBLGVBQ25DLDhEQUFDZ0M7WUFBS0MsV0FBVTs7Z0JBQ2JqQjs4QkFDRCw4REFBQ2dCO29CQUFLQyxXQUFVOztzQ0FDZCw4REFBQ0M7c0NBQUdsQjs7Ozs7O3NDQUNKLDhEQUFDbUI7NEJBQUlGLFdBQVU7c0NBQ1pmLGVBQ0dBLHlCQUFBQSwwQkFBQUEsS0FBQUEsSUFBQUEsYUFBY2tCLElBQUksQ0FBQyxRQUNuQm5CLDZCQUFBQSw4QkFBQUEsS0FBQUEsSUFBQUEsaUJBQWtCbUIsSUFBSSxDQUFDLEtBQUs7Ozs7OztzQ0FFbEMsOERBQUNEOzRCQUFJRixXQUFVO3NDQUFRZDs7Ozs7Ozs7Ozs7Ozs7Ozs7O1FBSzdCLElBQUksZ0JBQWlCQyxvQkFBcUIsQ0FBQ0YsY0FBYztZQUN2RE4sVUFBVWIsMERBQWtCQSxDQUMxQmEsU0FDQUcsSUFBSUYsa0JBQ0pHLFVBQVVYLE1BQU0sRUFDaEIwQjtZQUVGbEIsbUJBQ0VBLG1CQUFtQmtCLGVBQWUxQixNQUFNLEdBQUdXLFVBQVVYLE1BQU07UUFDL0QsQ0FBQztJQUNIO0lBRUEsT0FBT087QUFDVDtBQUNPLFNBQVN5QixjQUNkQyxZQUFZLEVBQ1o5QixpQkFBaUIsRUFDakJDLFFBQVEsRUFDUkMsVUFBVSxFQUNWQyx1QkFBdUIsRUFDdkI7SUFDQSxJQUFJNEIsbUJBQW1CakMsd0JBQ3JCZ0MsY0FDQTlCLG1CQUNBQyxVQUNBQyxZQUNBQztJQUdGLElBQUk2QiwwQ0FBMENELGlCQUFpQkUsT0FBTyxDQUNwRSxtQkFDQXZDO0lBR0YsOENBQThDO0lBQzlDLElBQUl3Qyx5QkFBeUJGLHdDQUF3Q0MsT0FBTyxDQUMxRSx5QkFDQXZDO0lBR0YsMklBQTJJO0lBQzNJLE1BQU15QyxRQUFRLElBQUlDLE9BQU8sZ0JBQWdCM0MsaUJBQWlCO0lBQzFELElBQUk0Qyw0Q0FDRkgsdUJBQXVCRCxPQUFPLENBQUNFLE9BQU87SUFFeEMsK0NBQStDO0lBQy9DLElBQUlHLDhCQUNGRCwwQ0FBMENFLFVBQVUsQ0FDbEQ5QyxpQkFDQTtJQUdKLE9BQU82QztBQUNULENBQUM7QUFFTSxTQUFTRSxpQkFBaUJDLFFBQVEsRUFBRTtJQUN6Q0EsU0FBU25DLE9BQU8sQ0FBQyxTQUFVTyxJQUFJLEVBQUVOLENBQUMsRUFBRTtRQUNsQ2tDLFFBQVEsQ0FBQ2xDLEVBQUUsR0FBR00sS0FBS0ksV0FBVztJQUNoQztJQUNBLE9BQU93QixTQUFTQyxJQUFJLENBQUMsQ0FBQ0MsR0FBR2pCLElBQU1BLEVBQUU3QixNQUFNLEdBQUc4QyxFQUFFOUMsTUFBTTtBQUNwRCxDQUFDO0FBRUQ7Ozs7OztFQU1FLEdBQ0YsU0FBUytDLHdCQUF3QkMsTUFBTSxFQUFFQyxVQUFVLEVBQUVDLFNBQVMsRUFBRWxDLElBQUksRUFBRTtJQUNwRSwrQkFBK0I7SUFDL0IsMERBQTBEO0lBQzFELElBQUltQyxrQkFBa0I7UUFDcEJDLFlBQVksS0FBSztRQUNqQkMsZUFBZSxLQUFLO1FBQ3BCQyxpQkFBaUIsQ0FBQztRQUNsQkMsZUFBZSxDQUFDO1FBQ2hCQyxvQkFBb0IsQ0FBQztRQUNyQkMsa0JBQWtCLENBQUM7SUFDckI7SUFFQSxnRUFBZ0U7SUFDaEUsSUFBSUMseUJBQXlCVixPQUFPVyxTQUFTLENBQUNWO0lBQzlDLElBQUlXLGFBQWFGLHVCQUF1QkcsT0FBTyxDQUFDN0MsUUFBUWlDO0lBRXhELHVDQUF1QztJQUN2QyxJQUFJVyxhQUFhWCxZQUFZLE9BQU9FO0lBRXBDLHVEQUF1RDtJQUN2RCx1REFBdUQ7SUFDdkRBLGdCQUFnQkMsVUFBVSxHQUFHLElBQUk7SUFDakNELGdCQUFnQkcsZUFBZSxHQUFHTTtJQUNsQ1QsZ0JBQWdCSSxhQUFhLEdBQUdLLGFBQWE1QyxLQUFLaEIsTUFBTSxHQUFHO0lBRTNELHFCQUFxQjtJQUNyQixJQUFJOEQsaUJBQWlCWixVQUFVYSxPQUFPLENBQUNmO0lBRXZDLHdEQUF3RDtJQUN4RCxxREFBcUQ7SUFDckQsSUFBSWdCLHVCQUF1QkYsZUFBZUcsVUFBVSxDQUFDTDtJQUVyRCwwRUFBMEU7SUFDMUUsd0VBQXdFO0lBQ3hFLCtCQUErQjtJQUMvQixJQUFJSSxxQkFBcUJFLEtBQUssR0FBR04sWUFBWSxPQUFPVDtJQUVwRDs7OztJQUlFLEdBRUYsa0VBQWtFO0lBQ2xFLElBQUlnQixzQkFBc0JMLGVBQWVHLFVBQVUsQ0FDakRkLGdCQUFnQkksYUFBYTtJQUcvQiw2REFBNkQ7SUFDN0QsSUFBSWEsMkJBQ0ZELG9CQUFvQkQsS0FBSyxHQUFHQyxvQkFBb0JKLE9BQU8sQ0FBQy9ELE1BQU0sR0FBRztJQUVuRSxzRkFBc0Y7SUFDdEYsaUZBQWlGO0lBQ2pGLHdCQUF3QjtJQUN4QixJQUFJb0UsNEJBQTRCakIsZ0JBQWdCSSxhQUFhLEVBQUU7UUFDN0QsMENBQTBDO1FBQzFDSixnQkFBZ0JFLGFBQWEsR0FBRyxJQUFJO1FBQ3BDRixnQkFBZ0JLLGtCQUFrQixHQUFHUSxxQkFBcUJFLEtBQUs7UUFDL0RmLGdCQUFnQk0sZ0JBQWdCLEdBQUdXO0lBQ3JDLENBQUM7SUFFRCxPQUFPakI7QUFDVDtBQUVBOzs7Ozs7O0VBT0UsR0FDRixTQUFTa0IsZ0JBQ1ByQixNQUFNLEVBQ05zQixXQUFXLEVBSVg7UUFIQUMsZ0JBQUFBLGlFQUFnQixLQUFLLEVBQ3JCQyx5REFDQUM7SUFFQSwyRUFBMkU7SUFDM0UsSUFBSUMsYUFBYTFCO0lBQ2pCLHdFQUF3RTtJQUN4RSxJQUFJLENBQUN1QixlQUFlO1FBQ2xCdkIsU0FBU0EsT0FBTzVCLFdBQVc7SUFDN0IsQ0FBQztJQUVELHFEQUFxRDtJQUNyRCxJQUFJOEIsWUFBWSxJQUFJeUIsS0FBS0MsU0FBUyxDQUFDSixTQUFTSyxRQUFRLEVBQUU7UUFDcERDLGFBQWE7SUFDZjtJQUVBLElBQUlDLFNBQVNDLE1BQU07SUFFbkIsZ0RBQWdEO0lBQ2hEVix3QkFBQUEseUJBQUFBLEtBQUFBLElBQUFBLFlBQWFXLFdBQVcsQ0FBQ3hFLE9BQU8sQ0FBQyxTQUFVTyxJQUFJLEVBQUU7UUFDL0Msd0VBQXdFO1FBQ3hFLElBQUlrRSxtQkFBbUI7UUFFdkIsMERBQTBEO1FBQzFELElBQUkvQixrQkFBa0JKLHdCQUNwQkMsUUFDQWtDLGtCQUNBaEMsV0FDQWxDO1FBR0YsMERBQTBEO1FBQzFELE1BQ0VtQyxnQkFBZ0JDLFVBQVUsSUFDMUJvQixTQUFTSyxRQUFRLEtBQUtKLGdCQUFnQixDQUFDLEVBQUUsQ0FBQ1UsY0FBYyxDQUN4RDtZQUNBLDJFQUEyRTtZQUMzRSxxREFBcUQ7WUFDckRELG1CQUFtQi9CLGdCQUFnQkksYUFBYSxHQUFHO1lBRW5ELDRFQUE0RTtZQUM1RSw2REFBNkQ7WUFDN0QsSUFBSUosZ0JBQWdCRSxhQUFhLEVBQUU7Z0JBQ2pDLDRFQUE0RTtnQkFDNUUsSUFBSU8sYUFBYVQsZ0JBQWdCRyxlQUFlO2dCQUVoRCw4RUFBOEU7Z0JBQzlFLDBDQUEwQztnQkFDMUMsSUFBSThCLGVBQWVWLFdBQVdmLFNBQVMsQ0FDckNDLFlBQ0FBLGFBQWE1QyxLQUFLaEIsTUFBTTtnQkFHMUIsa0NBQWtDO2dCQUNsQytFLE9BQU9NLElBQUksQ0FBQztvQkFBQ3pCO29CQUFZd0I7aUJBQWE7Z0JBRXRDLGtFQUFrRTtnQkFDbEUsd0RBQXdEO2dCQUN4RCxFQUFFO2dCQUNGLDJEQUEyRDtnQkFDM0QsaUVBQWlFO2dCQUNqRSxRQUFRO2dCQUNScEMsU0FBU0EsT0FBT1osT0FBTyxDQUFDcEIsTUFBTSxJQUFJakIsTUFBTSxDQUFDaUIsS0FBS2hCLE1BQU07WUFDdEQsQ0FBQztZQUVELHdFQUF3RTtZQUN4RSw0Q0FBNEM7WUFDNUNtRCxrQkFBa0JKLHdCQUNoQkMsUUFDQWtDLGtCQUNBaEMsV0FDQWxDO1FBRUo7SUFDRixFQUFFO0lBRUZzRCx3QkFBQUEseUJBQUFBLEtBQUFBLElBQUFBLFlBQWFnQixjQUFjLENBQUM3RSxPQUFPLENBQUMsU0FBVU8sSUFBSSxFQUFFO1FBQ2xELHdFQUF3RTtRQUN4RSxJQUFJa0UsbUJBQW1CO1FBRXZCLDBEQUEwRDtRQUMxRCxJQUFJL0Isa0JBQWtCSix3QkFDcEJDLFFBQ0FrQyxrQkFDQWhDLFdBQ0FsQztRQUdGLDBEQUEwRDtRQUMxRCxNQUNFbUMsZ0JBQWdCQyxVQUFVLElBQzFCb0IsU0FBU0ssUUFBUSxLQUFLSixnQkFBZ0IsQ0FBQyxFQUFFLENBQUNjLGNBQWMsQ0FDeEQ7WUFDQSwyRUFBMkU7WUFDM0UscURBQXFEO1lBQ3JETCxtQkFBbUIvQixnQkFBZ0JJLGFBQWEsR0FBRztZQUVuRCw0RUFBNEU7WUFDNUUsNkRBQTZEO1lBQzdELElBQUlKLGdCQUFnQkUsYUFBYSxFQUFFO2dCQUNqQyw0RUFBNEU7Z0JBQzVFLElBQUlPLGFBQWFULGdCQUFnQkcsZUFBZTtnQkFFaEQsOEVBQThFO2dCQUM5RSwwQ0FBMEM7Z0JBQzFDLElBQUk4QixlQUFlVixXQUFXZixTQUFTLENBQ3JDQyxZQUNBQSxhQUFhNUMsS0FBS2hCLE1BQU07Z0JBRzFCLGtDQUFrQztnQkFDbEMrRSxPQUFPTSxJQUFJLENBQUM7b0JBQUN6QjtvQkFBWXdCO2lCQUFhO2dCQUV0QyxrRUFBa0U7Z0JBQ2xFLHdEQUF3RDtnQkFDeEQsRUFBRTtnQkFDRiwyREFBMkQ7Z0JBQzNELGlFQUFpRTtnQkFDakUsUUFBUTtnQkFDUnBDLFNBQVNBLE9BQU9aLE9BQU8sQ0FBQ3BCLE1BQU0sSUFBSWpCLE1BQU0sQ0FBQ2lCLEtBQUtoQixNQUFNO1lBQ3RELENBQUM7WUFFRCx3RUFBd0U7WUFDeEUsNENBQTRDO1lBQzVDbUQsa0JBQWtCSix3QkFDaEJDLFFBQ0FrQyxrQkFDQWhDLFdBQ0FsQztRQUVKO0lBQ0YsRUFBRTtJQUVGLDRDQUE0QztJQUM1QyxPQUFPK0QsT0FBT2xDLElBQUksQ0FBQyxDQUFDQyxHQUFHakIsSUFBTWlCLENBQUMsQ0FBQyxFQUFFLEdBQUdqQixDQUFDLENBQUMsRUFBRTtBQUMxQztBQUVPLE1BQU0yRCxpQkFBaUIsQ0FBQ3RGLE1BQU0wQyxVQUFVNEIsVUFBVUMsbUJBQXFCO0lBQzVFLElBQUlGLGdCQUFnQixLQUFLO0lBRXpCLElBQUlyRSxNQUFNO1FBQ1IsT0FBT21FLGdCQUNMbkUsTUFDQTBDLFVBQ0EyQixlQUNBQyxVQUNBQztJQUVKLE9BQU87UUFDTCxPQUFPLEVBQUU7SUFDWCxDQUFDO0FBQ0gsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9nbG9zc2FyeVV0aWxzLmpzPzhkODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVwbGFjZVRleHRBdEluZGV4IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcblxuY29uc3QgcmVwbGFjZW1lbnRDb2RlID0gXCJYeGNENUpaNzNQRGdNNFBCRFdZdGZLTUtBYWtTdVJzR1wiO1xuXG5mdW5jdGlvbiByZXBsYWNlbWVudEZ1bmN0aW9uKG0pIHtcbiAgcmV0dXJuIHJlcGxhY2VtZW50Q29kZS5yZXBlYXQobS5sZW5ndGgpO1xufVxuXG5jb25zdCByZXBsYWNlVGV4dFdpdGhHbG9zc2FyeSA9IChcbiAgdGV4dCxcbiAgdGVybU1hdGNoR2xvc3NhcnksXG4gIHRlcm1MaXN0LFxuICBzb3VyY2VDZWxsLFxuICB0ZXJtU291cmNlTWF0Y2hHbG9zc2FyeVxuKSA9PiB7XG4gIGxldCBuZXdUZXh0ID0gdGV4dDtcbiAgbGV0IGluY3JlYXNlZFRvb2x0aXAgPSAwO1xuXG4gIHRlcm1NYXRjaEdsb3NzYXJ5LmZvckVhY2goKFtpLCB0ZXJtTWF0Y2hdKSA9PiB7XG4gICAgbGV0IHRyYW5sYXRpb25PZlRlcm0sIHNvdXJjZU9mVGVybSwgdGVybU5vdGU7XG4gICAgbGV0IHNvdXJjZVRlcm1BcHBlYXIgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgdGVybSBvZiB0ZXJtTGlzdCkge1xuICAgICAgaWYgKFxuICAgICAgICB0ZXJtLnNvdXJjZVZhbHVlcy5zb21lKFxuICAgICAgICAgICh2YWx1ZSkgPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdGVybU1hdGNoLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRyYW5sYXRpb25PZlRlcm0gPSB0ZXJtLnRyYW5zbGF0aW9ucztcbiAgICAgICAgdGVybU5vdGUgPSB0ZXJtLm5vdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGVybS50cmFuc2xhdGlvbnMuc29tZShcbiAgICAgICAgICAodmFsdWUpID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHRlcm1NYXRjaC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBzb3VyY2VPZlRlcm0gPSB0ZXJtLnNvdXJjZVZhbHVlcztcbiAgICAgICAgdGVybU5vdGUgPSB0ZXJtLm5vdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNvdXJjZVRlcm1BcHBlYXIgPSBzb3VyY2VPZlRlcm0/LnNvbWUoKHZhbHVlMikgPT5cbiAgICAgIHRlcm1Tb3VyY2VNYXRjaEdsb3NzYXJ5Py5zb21lKFxuICAgICAgICAoW18sIHZhbHVlMV0pID0+IHZhbHVlMS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZTIudG9Mb3dlckNhc2UoKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCB0b29sdGlwQ29udGVudCA9IHJlbmRlclRvU3RyaW5nKFxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZ2xvc3NhcnktdG9vbHRpcFwiPlxuICAgICAgICB7dGVybU1hdGNofVxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0b29sdGlwXCI+XG4gICAgICAgICAgPGI+e3Rlcm1NYXRjaH08L2I+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0cmFuc2xhdGVWYWx1ZVwiPlxuICAgICAgICAgICAge3NvdXJjZU9mVGVybVxuICAgICAgICAgICAgICA/IHNvdXJjZU9mVGVybT8uam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgIDogdHJhbmxhdGlvbk9mVGVybT8uam9pbihcIiwgXCIpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibm90ZVwiPnt0ZXJtTm90ZX08L2Rpdj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9zcGFuPlxuICAgICk7XG5cbiAgICBpZiAoKHNvdXJjZU9mVGVybSAmJiBzb3VyY2VUZXJtQXBwZWFyKSB8fCAhc291cmNlT2ZUZXJtKSB7XG4gICAgICBuZXdUZXh0ID0gcmVwbGFjZVRleHRBdEluZGV4KFxuICAgICAgICBuZXdUZXh0LFxuICAgICAgICBpICsgaW5jcmVhc2VkVG9vbHRpcCxcbiAgICAgICAgdGVybU1hdGNoLmxlbmd0aCxcbiAgICAgICAgdG9vbHRpcENvbnRlbnRcbiAgICAgICk7XG4gICAgICBpbmNyZWFzZWRUb29sdGlwID1cbiAgICAgICAgaW5jcmVhc2VkVG9vbHRpcCArIHRvb2x0aXBDb250ZW50Lmxlbmd0aCAtIHRlcm1NYXRjaC5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3VGV4dDtcbn07XG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheUFzSFRNTChcbiAgdGV4dEFyZWFUZXh0LFxuICB0ZXJtTWF0Y2hHbG9zc2FyeSxcbiAgdGVybUxpc3QsXG4gIHNvdXJjZUNlbGwsXG4gIHRlcm1Tb3VyY2VNYXRjaEdsb3NzYXJ5XG4pIHtcbiAgbGV0IHRleHRXaXRoR2xvc3NhcnkgPSByZXBsYWNlVGV4dFdpdGhHbG9zc2FyeShcbiAgICB0ZXh0QXJlYVRleHQsXG4gICAgdGVybU1hdGNoR2xvc3NhcnksXG4gICAgdGVybUxpc3QsXG4gICAgc291cmNlQ2VsbCxcbiAgICB0ZXJtU291cmNlTWF0Y2hHbG9zc2FyeVxuICApO1xuXG4gIGxldCB0ZXh0V2l0aFNwYWNlc0JlZm9yZVB1bmN0dWF0aW9uUmVwbGFjZWQgPSB0ZXh0V2l0aEdsb3NzYXJ5LnJlcGxhY2UoXG4gICAgLyArKD89W1xcLlxcIVxcP10pL2csXG4gICAgcmVwbGFjZW1lbnRGdW5jdGlvblxuICApO1xuXG4gIC8vIGLDtGkgxJFlbiBuaOG7r25nIGNo4buXIGPDsyBoxqFuIGhhaSBk4bqldSBjw6FjaCBsaeG7gW4uXG4gIGxldCB0ZXh0V2l0aFNwYWNlc1JlcGxhY2VkID0gdGV4dFdpdGhTcGFjZXNCZWZvcmVQdW5jdHVhdGlvblJlcGxhY2VkLnJlcGxhY2UoXG4gICAgLyg/PD0gKSArL2csXG4gICAgcmVwbGFjZW1lbnRGdW5jdGlvblxuICApO1xuXG4gIC8vIGtoaSBuw6BvIGThuqV1IGPDoWNoIHRo4burYSB4deG6pXQgaGnhu4duIG5nYXkgc2F1IGThuqV1IC4gPyAhLCBtw6xuaCB0aGF5IHRo4bq/IGThuqV1IOKOtSDEkeG6p3UgdGnDqm4gYuG6sW5nICZuYnNwOyDEkeG7gyBjaG8gcGjDqXAgdXNlciBjw7MgaGFpIGThuqV1IGPDoWNoIHNhdSAuID8gIS5cbiAgY29uc3QgcmVnZXggPSBuZXcgUmVnRXhwKFwiKD88PVsuPyFdKSBcIiArIHJlcGxhY2VtZW50Q29kZSwgXCJnXCIpO1xuICBsZXQgdGV4dEFsbG93aW5nRG91YmxlU3BhY2VBZnRlckVuZE9mU2VudGVuY2UgPVxuICAgIHRleHRXaXRoU3BhY2VzUmVwbGFjZWQucmVwbGFjZShyZWdleCwgXCIgJm5ic3A7XCIpO1xuXG4gIC8vIHRoYXkgdGjhur8gY8OhYyBk4bqldSBjw6FjaCB0aOG7q2EgYuG6sW5nIGThuqV1IOKOtSBtw6B1IGThu49cbiAgbGV0IHRleHRXaXRoU3BhY2VzQXNVbmRlcnNjb3JlcyA9XG4gICAgdGV4dEFsbG93aW5nRG91YmxlU3BhY2VBZnRlckVuZE9mU2VudGVuY2UucmVwbGFjZUFsbChcbiAgICAgIHJlcGxhY2VtZW50Q29kZSxcbiAgICAgIFwiPGZvbnQgY29sb3I9I0YwMD7ijrU8L2ZvbnQ+XCJcbiAgICApO1xuXG4gIHJldHVybiB0ZXh0V2l0aFNwYWNlc0FzVW5kZXJzY29yZXM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzb3J0R2xvc3NhcnlMaXN0KGdsb3NzYXJ5KSB7XG4gIGdsb3NzYXJ5LmZvckVhY2goZnVuY3Rpb24gKHRlcm0sIGkpIHtcbiAgICBnbG9zc2FyeVtpXSA9IHRlcm0udG9Mb3dlckNhc2UoKTtcbiAgfSk7XG4gIHJldHVybiBnbG9zc2FyeS5zb3J0KChhLCBiKSA9PiBiLmxlbmd0aCAtIGEubGVuZ3RoKTtcbn1cblxuLyoqXG4gKiBBIGNvbXBsZXRlIG1hdGNoIG9mIHRlcm0gaW4gc3RyaW5nIGlzIHdoZW4gdGVybSBtYXRjaGVzIGEgY29tcGxldGUgd29yZCBvclxuICogcGhyYXNlIGluIHN0cmluZyBhbmQgbm8gcGFydGlhbCB3b3JkcyBpbiBzdHJpbmcgYXJlIGxlZnQgaGFuZ2luZyBvZmYgdGhlXG4gKiBzdGFydCBvciBlbmQuIEZvciBleGFtcGxlLCBpZiB0ZXJtIGlzIFwiZnVsbFwiIGFuZCBzdHJpbmcgaXMgXCJiZWF1dGlmdWxseVwiLCB0aGF0XG4gKiBpcyBub3QgYSBjb21wbGV0ZSBtYXRjaCBiZWNhdXNlIFwiYmVhdXRpXCIgaGFuZ3Mgb2ZmIHRoZSBiZWdpbm5pbmcgYW5kIFwieVwiIGV4dGVuZHNcbiAqIGJlZm9yZSB0aGUgc3RhcnQgb2YgdGhlIHNlY3Rpb24gb2YgbWF0Y2hpbmcgdGV4dC5cbiAqKi9cbmZ1bmN0aW9uIGNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzKHN0cmluZywgc3RhcnRJbmRleCwgc2VnbWVudGVyLCB0ZXJtKSB7XG4gIC8vIGluaXRpYWxpemUgdmFsdWVzIGZvciBvdXRwdXRcbiAgLy8gdGhpcyBpcyB0aGUgb3V0cHV0IGFzIGl0IHNob3VsZCBiZSBpZiBubyBtYXRjaCBpcyBmb3VuZFxuICBsZXQgbWF0Y2hCb3VuZGFyaWVzID0ge1xuICAgIG5haXZlTWF0Y2g6IGZhbHNlLFxuICAgIGNvbXBsZXRlTWF0Y2g6IGZhbHNlLFxuICAgIG5haXZlTWF0Y2hTdGFydDogLTEsXG4gICAgbmFpdmVNYXRjaEVuZDogLTEsXG4gICAgY29tcGxldGVNYXRjaFN0YXJ0OiAtMSxcbiAgICBjb21wbGV0ZU1hdGNoRW5kOiAtMSxcbiAgfTtcblxuICAvLyBmaW5kIGEgbWF0Y2ggYnkgc2ltcGxlIHN0cmluZyBzZWFyY2gsIHN0YXJ0aW5nIGF0IHN0YXJ0SW5kZXguXG4gIGxldCB1bnNlYXJjaGVkUGFydE9mU3RyaW5nID0gc3RyaW5nLnN1YnN0cmluZyhzdGFydEluZGV4KTtcbiAgbGV0IG1hdGNoSW5kZXggPSB1bnNlYXJjaGVkUGFydE9mU3RyaW5nLmluZGV4T2YodGVybSkgKyBzdGFydEluZGV4O1xuXG4gIC8vIGlmIG5vIHNpbXBsZSBtYXRjaCB3YXMgZm91bmQsIHJldHVyblxuICBpZiAobWF0Y2hJbmRleCA8IHN0YXJ0SW5kZXgpIHJldHVybiBtYXRjaEJvdW5kYXJpZXM7XG5cbiAgLy8gaWYgd2UgcmVhY2ggdGhpcyBwb2ludCB0aGVuIGEgbmFpdmUgbWF0Y2ggd2FzIGZvdW5kLlxuICAvLyB1cGRhdGUgbmFpdmUgbWF0Y2ggYm91bmRhcnkgaW5mb3JtYXRpb24gYWNjb3JkaW5nbHkuXG4gIG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoID0gdHJ1ZTtcbiAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hTdGFydCA9IG1hdGNoSW5kZXg7XG4gIG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoRW5kID0gbWF0Y2hJbmRleCArIHRlcm0ubGVuZ3RoIC0gMTtcblxuICAvLyBzZWdtZW50IHRoZSBzdHJpbmdcbiAgbGV0IHN0cmluZ1NlZ21lbnRzID0gc2VnbWVudGVyLnNlZ21lbnQoc3RyaW5nKTtcblxuICAvLyBnZXQgdGhlIHN0cmluZyBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIG1hdGNoIGluZGV4LlxuICAvLyB0aGlzIGlzIHRoZSBmaXJzdCB3b3JkIGluIHN0cmluZyB0aGF0IG1hdGNoZXMgdGVybVxuICBsZXQgZmlyc3RNYXRjaGluZ1NlZ21lbnQgPSBzdHJpbmdTZWdtZW50cy5jb250YWluaW5nKG1hdGNoSW5kZXgpO1xuXG4gIC8vIGlmIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hpbmcgc2VnbWVudCBkb2Vzbid0IG1hdGNoIHRoZSBtYXRjaEluZGV4IGZvdW5kXG4gIC8vIGJ5IG5haXZlIHNlYXJjaCwgaXQncyBhIHBhcnRpYWwgbWF0Y2guIFJldHVybiB0aGUgYm91bmRhcnkgaW5mbyBhcy1pc1xuICAvLyB3aXRob3V0IGNvbXBsZXRlIG1hdGNoIGRhdGEuXG4gIGlmIChmaXJzdE1hdGNoaW5nU2VnbWVudC5pbmRleCA8IG1hdGNoSW5kZXgpIHJldHVybiBtYXRjaEJvdW5kYXJpZXM7XG5cbiAgLyoqXG4gICAqIGF0IHRoaXMgcG9pbnQgd2Uga25vdyB0aGF0IHRoZSBmaXJzdCBjaGFyYWN0ZXIgaW4gXCJ0ZXJtXCIgaXMgdGhlIGZpcnN0XG4gICAqIGNoYXJhY3RlciBvZiBhIHNlZ21lbnQgaW4gc3RyaW5nLiBub3cgd2UgbmVlZCB0byBjaGVjayBpZiB0aGUgbGFzdCBjaGFyYWN0ZXJcbiAgICogaW4gXCJ0ZXJtXCIgaXMgYWxzbyBhbGlnbmVkIHdpdGggdGhlIGxhc3QgY2hhcmFjdGVyIG9mIGEgc2VnbWVudCBpbiBzdHJpbmcuXG4gICAqKi9cblxuICAvLyBnZXQgdGhlIHN0cmluZyBzZWdtZW50IHRoYXQgY29udGFpbnMgdGhlIGxhc3QgY2hhcmFjdGVyIG9mIHRlcm1cbiAgbGV0IGxhc3RNYXRjaGluZ1NlZ21lbnQgPSBzdHJpbmdTZWdtZW50cy5jb250YWluaW5nKFxuICAgIG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoRW5kXG4gICk7XG5cbiAgLy8gZ2V0IHRoZSBpbmRleCBvZiB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGhhdCBzdHJpbmcgc2VnbWVudFxuICBsZXQgZW5kT2ZMYXN0TWF0Y2hpbmdTZWdtZW50ID1cbiAgICBsYXN0TWF0Y2hpbmdTZWdtZW50LmluZGV4ICsgbGFzdE1hdGNoaW5nU2VnbWVudC5zZWdtZW50Lmxlbmd0aCAtIDE7XG5cbiAgLy8gaWYgdGhlIGVuZCBvZiB0aGUgbGFzdCBtYXRjaGluZyBzZWdtZW50IG1hdGNoZXMgd2l0aCB0aGUgZW5kIG9mIHRoZSBuYWl2ZSBcImluZGV4T2ZcIlxuICAvLyBtYXRjaCB0aGVuIHRoZSBtYXRjaCBpcyBhIGNvbXBsZXRlIG1hdGNoIHdpdGggbm8gZXh0cmEgd29yZCBjaGFyYWN0ZXJzIGhhbmdpbmdcbiAgLy8gb2ZmIHRoZSBzdGFydCBvciBlbmQuXG4gIGlmIChlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQgPT0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQpIHtcbiAgICAvLyB1cGRhdGUgdGhlIGNvbXBsZXRlIG1hdGNoIGJvdW5kYXJ5IGluZm9cbiAgICBtYXRjaEJvdW5kYXJpZXMuY29tcGxldGVNYXRjaCA9IHRydWU7XG4gICAgbWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2hTdGFydCA9IGZpcnN0TWF0Y2hpbmdTZWdtZW50LmluZGV4O1xuICAgIG1hdGNoQm91bmRhcmllcy5jb21wbGV0ZU1hdGNoRW5kID0gZW5kT2ZMYXN0TWF0Y2hpbmdTZWdtZW50O1xuICB9XG5cbiAgcmV0dXJuIG1hdGNoQm91bmRhcmllcztcbn1cblxuLyoqXG4gKiBTZWFyY2hlcyBcInN0cmluZ1wiIGZvciB0ZXJtcyBpbiBcImdsb3NzYXJ5XCIgYW5kIGdpdmVzIHRoZSBsb2NhdGlvbiB3aGVyZSBlYWNoIHRlcm0gYXBwZWFycy4gSWYgc2V2ZXJhbCBnbG9zc2FyeSB0ZXJtcyBvdmVybGFwLCBtYXRjaGluZyBvbiB0aGUgc2FtZSB3b3JkcyB0aGVuIHRoZSBsb25nZXN0IHRlcm0gdGFrZXMgcHJlY2VkZW5jZS5cbiAqXG4gKiBAcGFyYW0gc3RyaW5nIC0gdGhlIHRleHQgc3RyaW5nIGluIHdoaWNoIHdlIHdhbnQgdG8gc2VhcmNoIGZvciBnbG9zc2FyeSB0ZXJtc1xuICogQHBhcmFtIGdsb3NzYXJ5IC0gYW4gYXJyYXkgb2YgdGV4dCBzdHJpbmdzLCBhbGwgdGhlIHRlcm1zIGluIHRoZSBnbG9zc2FyeS4gVGhpcyBsaXN0IG1heSBjb250YWluIHNldmVyYWwgdGhvdXNhbmQgaXRlbXMuXG4gKiBAcGFyYW0gbGFuZ3VhZ2VDb2RlIC0gSVNPIDYzOS0xIGxhbmd1YWdlIGNvZGVcbiAqIEByZXR1cm5zIHthcnJheX0gLSBhIGxpc3Qgb2YgcGFpcnMgW2luZGV4LCB0ZXJtXSB3aGVyZSBpbnQgaXMgdGhlIGluZGV4IGF0IHdoaWNoIHRlcm0gYXBwZWFycyBpbiBzdHJpbmcuXG4gKiovXG5mdW5jdGlvbiBnbG9zc2FyeU1hdGNoZXMoXG4gIHN0cmluZyxcbiAgYWxsR2xvc3NhcnksXG4gIGNhc2VTZW5zaXRpdmUgPSBmYWxzZSxcbiAgdGV4dEluZm8sXG4gIG9yaWdpbmFsVGVybUxpc3Rcbikge1xuICAvLyBtYWtlIGEgY29weSBvZiBzdHJpbmcgc28gdGhhdCB0aGUgb3JpZ2luYWwgaXMgbm90IGxvc3Qgd2hlbiB3ZSBtb2RpZnkgaXRcbiAgbGV0IHN0cmluZ0NvcHkgPSBzdHJpbmc7XG4gIC8vIGlmIHRoZSBzZWFyY2ggaXMgbm90IGNhc2Utc2Vuc2l0aXZlLCBjb252ZXJ0IGV2ZXJ5dGhpbmcgdG8gbG93ZXIgY2FzZVxuICBpZiAoIWNhc2VTZW5zaXRpdmUpIHtcbiAgICBzdHJpbmcgPSBzdHJpbmcudG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vIHNwbGl0IHRoZSBzdHJpbmcgaW50byBzZWdtZW50cywgc2VwYXJhdGluZyBieSB3b3JkXG4gIGxldCBzZWdtZW50ZXIgPSBuZXcgSW50bC5TZWdtZW50ZXIodGV4dEluZm8ubGFuZ3VhZ2UsIHtcbiAgICBncmFudWxhcml0eTogXCJ3b3JkXCIsXG4gIH0pO1xuXG4gIGxldCBvdXRwdXQgPSBBcnJheSgwKTtcblxuICAvLyBmb3IgZWFjaCBsaXN0IG9mIHRlcm1zIGluIHRoZSBzb3J0ZWQgZ2xvc3NhcnlcbiAgYWxsR2xvc3Nhcnk/LnNyY0dsb3NzYXJ5LmZvckVhY2goZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAvLyB3ZSBzdGFydCBzZWFyY2hpbmcgZm9yIFwidGVybVwiIHN0YXJ0aW5nIGZyb20gdGhlIGJlZ2lubmluZyBvZiBcInN0cmluZ1wiXG4gICAgbGV0IHNlYXJjaFN0YXJ0SW5kZXggPSAwO1xuXG4gICAgLy8gZmluZCB0aGUgbG9jYXRpb24gaW4gXCJzdHJpbmdcIiB3aGVyZSB0aGUgXCJ0ZXJtXCIgaXMgZm91bmRcbiAgICBsZXQgbWF0Y2hCb3VuZGFyaWVzID0gY29tcGxldGVNYXRjaEJvdW5kYXJpZXMoXG4gICAgICBzdHJpbmcsXG4gICAgICBzZWFyY2hTdGFydEluZGV4LFxuICAgICAgc2VnbWVudGVyLFxuICAgICAgdGVybVxuICAgICk7XG5cbiAgICAvLyBpZiBcInRlcm1cIiB3YXMgZm91bmQgaW4gXCJzdHJpbmdcIiBieSBuYWl2ZSBpbmRleE9mIHNlYXJjaFxuICAgIHdoaWxlIChcbiAgICAgIG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoICYmXG4gICAgICB0ZXh0SW5mby5sYW5ndWFnZSA9PT0gb3JpZ2luYWxUZXJtTGlzdFswXS5zb3VyY2VMYW5ndWFnZVxuICAgICkge1xuICAgICAgLy8gc2luY2UgYSBuYWl2ZSBtYXRjaCB3YXMgZm91bmQsIHdlIHVwZGF0ZSB0aGUgc2VhcmNoU3RhcnRJbmRleCB0byBwcmV2ZW50XG4gICAgICAvLyBmaW5kaW5nIHRoYXQgc2FtZSBuYWl2ZSBtYXRjaCBhZ2FpbiBpbiB0aGUgZnV0dXJlLlxuICAgICAgc2VhcmNoU3RhcnRJbmRleCA9IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoRW5kICsgMTtcblxuICAgICAgLy8gaWYgdGhlIG1hdGNoIGlzIGEgY29tcGxldGUgbWF0Y2gsIHJlY29yZCBpdCwgdGhlbiBlcmFzZSBpdCBmcm9tIHN0cmluZyB0b1xuICAgICAgLy8gcHJldmVudCBzaG9ydGVyIHRlcm1zIGZyb20gZG91YmxlLW1hdGNoaW5nIG9uIGl0IGxhdGVyIG9uLlxuICAgICAgaWYgKG1hdGNoQm91bmRhcmllcy5jb21wbGV0ZU1hdGNoKSB7XG4gICAgICAgIC8vIGdldCBhIHNob3J0ZXIgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGV4IHdoZXJlIHRoZSBuYWl2ZSBtYXRjaCB3YXMgZm91bmRcbiAgICAgICAgbGV0IG1hdGNoSW5kZXggPSBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaFN0YXJ0O1xuXG4gICAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgdGVybSBmcm9tIHRoZSBjb3B5IG9mIHN0cmluZywgaW4gY2FzZSB0aGUgY2FzZS1pbnNlbnRpdGl2ZVxuICAgICAgICAvLyBzZWFyY2ggY2F1c2VkIHRoZSBzdHJpbmcgdG8gYmUgbW9kaWZpZWRcbiAgICAgICAgbGV0IG9yaWdpbmFsVGVybSA9IHN0cmluZ0NvcHkuc3Vic3RyaW5nKFxuICAgICAgICAgIG1hdGNoSW5kZXgsXG4gICAgICAgICAgbWF0Y2hJbmRleCArIHRlcm0ubGVuZ3RoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSB0ZXJtIHRvIHRoZSBvdXRwdXQgbGlzdFxuICAgICAgICBvdXRwdXQucHVzaChbbWF0Y2hJbmRleCwgb3JpZ2luYWxUZXJtXSk7XG5cbiAgICAgICAgLy8gRXJhc2UgdGhlIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycyBpbiBzdHJpbmcgc28gdGhhdCBzdWJzZXF1ZW50XG4gICAgICAgIC8vIHRlcm1zIGluIHRoZSBnbG9zc2FyeSBjYW4ndCBtYXRjaCB3aXRoIHRoZSBzYW1lIHRleHQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJlY2F1c2Ugb3VyIGdsb3NzYXJ5IGlzIHNvcnRlZCB3aXRoIGxvbmdlc3QgdGVybXMgZmlyc3QsXG4gICAgICAgIC8vIHRoaXMgZW5zdXJlcyB0aGF0IGxvbmdlciBtYXRjaGVzIHRha2UgcHJlY2VuZGVuY2Ugb3ZlciBzaG9ydGVyXG4gICAgICAgIC8vIG9uZXMuXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHRlcm0sIFwiIFwiLnJlcGVhdCh0ZXJtLmxlbmd0aCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlcmUgYXJlIG90aGVyIHBsYWNlcyBpbiBcInN0cmluZ1wiIHRoYXQgbWF0Y2ggXCJ0ZXJtXCIuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUsIHRoZSB3aGlsZSBsb29wIHdpbGwgcmVwZWF0LlxuICAgICAgbWF0Y2hCb3VuZGFyaWVzID0gY29tcGxldGVNYXRjaEJvdW5kYXJpZXMoXG4gICAgICAgIHN0cmluZyxcbiAgICAgICAgc2VhcmNoU3RhcnRJbmRleCxcbiAgICAgICAgc2VnbWVudGVyLFxuICAgICAgICB0ZXJtXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgYWxsR2xvc3Nhcnk/LnRhcmdldEdsb3NzYXJ5LmZvckVhY2goZnVuY3Rpb24gKHRlcm0pIHtcbiAgICAvLyB3ZSBzdGFydCBzZWFyY2hpbmcgZm9yIFwidGVybVwiIHN0YXJ0aW5nIGZyb20gdGhlIGJlZ2lubmluZyBvZiBcInN0cmluZ1wiXG4gICAgbGV0IHNlYXJjaFN0YXJ0SW5kZXggPSAwO1xuXG4gICAgLy8gZmluZCB0aGUgbG9jYXRpb24gaW4gXCJzdHJpbmdcIiB3aGVyZSB0aGUgXCJ0ZXJtXCIgaXMgZm91bmRcbiAgICBsZXQgbWF0Y2hCb3VuZGFyaWVzID0gY29tcGxldGVNYXRjaEJvdW5kYXJpZXMoXG4gICAgICBzdHJpbmcsXG4gICAgICBzZWFyY2hTdGFydEluZGV4LFxuICAgICAgc2VnbWVudGVyLFxuICAgICAgdGVybVxuICAgICk7XG5cbiAgICAvLyBpZiBcInRlcm1cIiB3YXMgZm91bmQgaW4gXCJzdHJpbmdcIiBieSBuYWl2ZSBpbmRleE9mIHNlYXJjaFxuICAgIHdoaWxlIChcbiAgICAgIG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoICYmXG4gICAgICB0ZXh0SW5mby5sYW5ndWFnZSA9PT0gb3JpZ2luYWxUZXJtTGlzdFswXS50YXJnZXRMYW5ndWFnZVxuICAgICkge1xuICAgICAgLy8gc2luY2UgYSBuYWl2ZSBtYXRjaCB3YXMgZm91bmQsIHdlIHVwZGF0ZSB0aGUgc2VhcmNoU3RhcnRJbmRleCB0byBwcmV2ZW50XG4gICAgICAvLyBmaW5kaW5nIHRoYXQgc2FtZSBuYWl2ZSBtYXRjaCBhZ2FpbiBpbiB0aGUgZnV0dXJlLlxuICAgICAgc2VhcmNoU3RhcnRJbmRleCA9IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoRW5kICsgMTtcblxuICAgICAgLy8gaWYgdGhlIG1hdGNoIGlzIGEgY29tcGxldGUgbWF0Y2gsIHJlY29yZCBpdCwgdGhlbiBlcmFzZSBpdCBmcm9tIHN0cmluZyB0b1xuICAgICAgLy8gcHJldmVudCBzaG9ydGVyIHRlcm1zIGZyb20gZG91YmxlLW1hdGNoaW5nIG9uIGl0IGxhdGVyIG9uLlxuICAgICAgaWYgKG1hdGNoQm91bmRhcmllcy5jb21wbGV0ZU1hdGNoKSB7XG4gICAgICAgIC8vIGdldCBhIHNob3J0ZXIgdmFyaWFibGUgbmFtZSBmb3IgdGhlIGluZGV4IHdoZXJlIHRoZSBuYWl2ZSBtYXRjaCB3YXMgZm91bmRcbiAgICAgICAgbGV0IG1hdGNoSW5kZXggPSBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaFN0YXJ0O1xuXG4gICAgICAgIC8vIGdldCB0aGUgb3JpZ2luYWwgdGVybSBmcm9tIHRoZSBjb3B5IG9mIHN0cmluZywgaW4gY2FzZSB0aGUgY2FzZS1pbnNlbnRpdGl2ZVxuICAgICAgICAvLyBzZWFyY2ggY2F1c2VkIHRoZSBzdHJpbmcgdG8gYmUgbW9kaWZpZWRcbiAgICAgICAgbGV0IG9yaWdpbmFsVGVybSA9IHN0cmluZ0NvcHkuc3Vic3RyaW5nKFxuICAgICAgICAgIG1hdGNoSW5kZXgsXG4gICAgICAgICAgbWF0Y2hJbmRleCArIHRlcm0ubGVuZ3RoXG4gICAgICAgICk7XG5cbiAgICAgICAgLy8gYWRkIHRoZSB0ZXJtIHRvIHRoZSBvdXRwdXQgbGlzdFxuICAgICAgICBvdXRwdXQucHVzaChbbWF0Y2hJbmRleCwgb3JpZ2luYWxUZXJtXSk7XG5cbiAgICAgICAgLy8gRXJhc2UgdGhlIGNvcnJlc3BvbmRpbmcgY2hhcmFjdGVycyBpbiBzdHJpbmcgc28gdGhhdCBzdWJzZXF1ZW50XG4gICAgICAgIC8vIHRlcm1zIGluIHRoZSBnbG9zc2FyeSBjYW4ndCBtYXRjaCB3aXRoIHRoZSBzYW1lIHRleHQuXG4gICAgICAgIC8vXG4gICAgICAgIC8vIEJlY2F1c2Ugb3VyIGdsb3NzYXJ5IGlzIHNvcnRlZCB3aXRoIGxvbmdlc3QgdGVybXMgZmlyc3QsXG4gICAgICAgIC8vIHRoaXMgZW5zdXJlcyB0aGF0IGxvbmdlciBtYXRjaGVzIHRha2UgcHJlY2VuZGVuY2Ugb3ZlciBzaG9ydGVyXG4gICAgICAgIC8vIG9uZXMuXG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHRlcm0sIFwiIFwiLnJlcGVhdCh0ZXJtLmxlbmd0aCkpO1xuICAgICAgfVxuXG4gICAgICAvLyBjaGVjayB0byBzZWUgaWYgdGhlcmUgYXJlIG90aGVyIHBsYWNlcyBpbiBcInN0cmluZ1wiIHRoYXQgbWF0Y2ggXCJ0ZXJtXCIuXG4gICAgICAvLyBJZiB0aGVyZSBhcmUsIHRoZSB3aGlsZSBsb29wIHdpbGwgcmVwZWF0LlxuICAgICAgbWF0Y2hCb3VuZGFyaWVzID0gY29tcGxldGVNYXRjaEJvdW5kYXJpZXMoXG4gICAgICAgIHN0cmluZyxcbiAgICAgICAgc2VhcmNoU3RhcnRJbmRleCxcbiAgICAgICAgc2VnbWVudGVyLFxuICAgICAgICB0ZXJtXG4gICAgICApO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gc29ydCB0aGUgb3V0cHV0IGJ5IHRoZSBpbmRpY2VzIGFuZCByZXR1cm5cbiAgcmV0dXJuIG91dHB1dC5zb3J0KChhLCBiKSA9PiBhWzBdIC0gYlswXSk7XG59XG5cbmV4cG9ydCBjb25zdCBkZXRlY3RHbG9zc2FyeSA9ICh0ZXh0LCBnbG9zc2FyeSwgdGV4dEluZm8sIG9yaWdpbmFsVGVybUxpc3QpID0+IHtcbiAgbGV0IGNhc2VTZW5zaXRpdmUgPSBmYWxzZTtcblxuICBpZiAodGV4dCkge1xuICAgIHJldHVybiBnbG9zc2FyeU1hdGNoZXMoXG4gICAgICB0ZXh0LFxuICAgICAgZ2xvc3NhcnksXG4gICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgdGV4dEluZm8sXG4gICAgICBvcmlnaW5hbFRlcm1MaXN0XG4gICAgKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn07XG4iXSwibmFtZXMiOlsicmVwbGFjZVRleHRBdEluZGV4IiwicmVuZGVyVG9TdHJpbmciLCJyZXBsYWNlbWVudENvZGUiLCJyZXBsYWNlbWVudEZ1bmN0aW9uIiwibSIsInJlcGVhdCIsImxlbmd0aCIsInJlcGxhY2VUZXh0V2l0aEdsb3NzYXJ5IiwidGV4dCIsInRlcm1NYXRjaEdsb3NzYXJ5IiwidGVybUxpc3QiLCJzb3VyY2VDZWxsIiwidGVybVNvdXJjZU1hdGNoR2xvc3NhcnkiLCJuZXdUZXh0IiwiaW5jcmVhc2VkVG9vbHRpcCIsImZvckVhY2giLCJpIiwidGVybU1hdGNoIiwidHJhbmxhdGlvbk9mVGVybSIsInNvdXJjZU9mVGVybSIsInRlcm1Ob3RlIiwic291cmNlVGVybUFwcGVhciIsInRlcm0iLCJzb3VyY2VWYWx1ZXMiLCJzb21lIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInRyYW5zbGF0aW9ucyIsIm5vdGUiLCJ2YWx1ZTIiLCJ2YWx1ZTEiLCJfIiwidG9vbHRpcENvbnRlbnQiLCJzcGFuIiwiY2xhc3NOYW1lIiwiYiIsImRpdiIsImpvaW4iLCJkaXNwbGF5QXNIVE1MIiwidGV4dEFyZWFUZXh0IiwidGV4dFdpdGhHbG9zc2FyeSIsInRleHRXaXRoU3BhY2VzQmVmb3JlUHVuY3R1YXRpb25SZXBsYWNlZCIsInJlcGxhY2UiLCJ0ZXh0V2l0aFNwYWNlc1JlcGxhY2VkIiwicmVnZXgiLCJSZWdFeHAiLCJ0ZXh0QWxsb3dpbmdEb3VibGVTcGFjZUFmdGVyRW5kT2ZTZW50ZW5jZSIsInRleHRXaXRoU3BhY2VzQXNVbmRlcnNjb3JlcyIsInJlcGxhY2VBbGwiLCJzb3J0R2xvc3NhcnlMaXN0IiwiZ2xvc3NhcnkiLCJzb3J0IiwiYSIsImNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzIiwic3RyaW5nIiwic3RhcnRJbmRleCIsInNlZ21lbnRlciIsIm1hdGNoQm91bmRhcmllcyIsIm5haXZlTWF0Y2giLCJjb21wbGV0ZU1hdGNoIiwibmFpdmVNYXRjaFN0YXJ0IiwibmFpdmVNYXRjaEVuZCIsImNvbXBsZXRlTWF0Y2hTdGFydCIsImNvbXBsZXRlTWF0Y2hFbmQiLCJ1bnNlYXJjaGVkUGFydE9mU3RyaW5nIiwic3Vic3RyaW5nIiwibWF0Y2hJbmRleCIsImluZGV4T2YiLCJzdHJpbmdTZWdtZW50cyIsInNlZ21lbnQiLCJmaXJzdE1hdGNoaW5nU2VnbWVudCIsImNvbnRhaW5pbmciLCJpbmRleCIsImxhc3RNYXRjaGluZ1NlZ21lbnQiLCJlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQiLCJnbG9zc2FyeU1hdGNoZXMiLCJhbGxHbG9zc2FyeSIsImNhc2VTZW5zaXRpdmUiLCJ0ZXh0SW5mbyIsIm9yaWdpbmFsVGVybUxpc3QiLCJzdHJpbmdDb3B5IiwiSW50bCIsIlNlZ21lbnRlciIsImxhbmd1YWdlIiwiZ3JhbnVsYXJpdHkiLCJvdXRwdXQiLCJBcnJheSIsInNyY0dsb3NzYXJ5Iiwic2VhcmNoU3RhcnRJbmRleCIsInNvdXJjZUxhbmd1YWdlIiwib3JpZ2luYWxUZXJtIiwicHVzaCIsInRhcmdldEdsb3NzYXJ5IiwidGFyZ2V0TGFuZ3VhZ2UiLCJkZXRlY3RHbG9zc2FyeSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/glossaryUtils.js\n"));

/***/ })

});
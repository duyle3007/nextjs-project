"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/file/[id]",{

/***/ "./utils/glossaryUtils.js":
/*!********************************!*\
  !*** ./utils/glossaryUtils.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"detectGlossary\": function() { return /* binding */ detectGlossary; },\n/* harmony export */   \"displayAsHTML\": function() { return /* binding */ displayAsHTML; },\n/* harmony export */   \"sortGlossaryList\": function() { return /* binding */ sortGlossaryList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./utils/utils.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/server */ \"./node_modules/react-dom/server.browser.js\");\n\n\n\nconst replacementCode = \"XxcD5JZ73PDgM4PBDWYtfKMKAakSuRsG\";\nfunction replacementFunction(m) {\n    return replacementCode.repeat(m.length);\n}\nconst replaceTextWithGlossary = (text, termMatchGlossary, termList, sourceCell, glossary, originalTermList)=>{\n    let newText = text;\n    let increasedTooltip = 0;\n    const termMatchGlossarySource = detectGlossary(sourceCell === null || sourceCell === void 0 ? void 0 : sourceCell.value, glossary, sourceCell, originalTermList);\n    if (text === \"string v\\xe0 Kabbalah c\\xf5i\") {\n        console.log(\"wutt\", termMatchGlossarySource);\n    }\n    termMatchGlossary.forEach((param)=>{\n        let [i, termMatch] = param;\n        let tranlationOfTerm, sourceOfTerm, termNote;\n        let sourceTermAppear = false;\n        for (const term of termList){\n            if (term.sourceValues.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                tranlationOfTerm = term.translations;\n                termNote = term.note;\n                break;\n            } else if (term.translations.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                sourceOfTerm = term.sourceValues;\n                termNote = term.note;\n                break;\n            }\n        }\n        if (text === \"string v\\xe0 Kabbalah c\\xf5i\") {\n            console.log(\"sourceOfTerm\", sourceOfTerm);\n            console.log(\"sourceCell\", sourceCell);\n            console.log(\"termMatchGlossarySource\", termMatchGlossarySource);\n        }\n        sourceTermAppear = sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.some((value2)=>{\n            return termMatchGlossarySource === null || termMatchGlossarySource === void 0 ? void 0 : termMatchGlossarySource.some((param)=>{\n                let [_, value1] = param;\n                return value1.toLowerCase() === value2.toLowerCase();\n            });\n        });\n        const tooltipContent = (0,react_dom_server__WEBPACK_IMPORTED_MODULE_2__.renderToString)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            className: \"glossary-tooltip\",\n            children: [\n                termMatch,\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"tooltip\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: termMatch\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 70,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"translateValue\",\n                            children: sourceOfTerm ? sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.join(\", \") : tranlationOfTerm === null || tranlationOfTerm === void 0 ? void 0 : tranlationOfTerm.join(\", \")\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 71,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"note\",\n                            children: termNote\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 76,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                    lineNumber: 69,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n            lineNumber: 67,\n            columnNumber: 7\n        }, undefined));\n        if (sourceOfTerm && sourceTermAppear || !sourceOfTerm) {\n            newText = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.replaceTextAtIndex)(newText, i + increasedTooltip, termMatch.length, tooltipContent);\n            increasedTooltip = increasedTooltip + tooltipContent.length - termMatch.length;\n        }\n    });\n    return newText;\n};\nfunction displayAsHTML(textAreaText, termMatchGlossary, termList, sourceCell, termMatchGlossarySource, originalTermList) {\n    let textWithGlossary = replaceTextWithGlossary(textAreaText, termMatchGlossary, termList, sourceCell, termMatchGlossarySource, originalTermList);\n    let textWithSpacesBeforePunctuationReplaced = textWithGlossary.replace(/ +(?=[\\.\\!\\?])/g, replacementFunction);\n    // bôi đen những chỗ có hơn hai dấu cách liền.\n    let textWithSpacesReplaced = textWithSpacesBeforePunctuationReplaced.replace(RegExp(\"(?<= ) +\", \"g\"), replacementFunction);\n    // khi nào dấu cách thừa xuất hiện ngay sau dấu . ? !, mình thay thế dấu ⎵ đầu tiên bằng &nbsp; để cho phép user có hai dấu cách sau . ? !.\n    const regex = new RegExp(\"(?<=[.?!]) \" + replacementCode, \"g\");\n    let textAllowingDoubleSpaceAfterEndOfSentence = textWithSpacesReplaced.replace(regex, \" &nbsp;\");\n    // thay thế các dấu cách thừa bằng dấu ⎵ màu dỏ\n    let textWithSpacesAsUnderscores = textAllowingDoubleSpaceAfterEndOfSentence.replaceAll(replacementCode, \"<font color=#F00>⎵</font>\");\n    return textWithSpacesAsUnderscores;\n}\nfunction sortGlossaryList(glossary) {\n    glossary.forEach(function(term, i) {\n        glossary[i] = term.toLowerCase();\n    });\n    return glossary.sort((a, b)=>b.length - a.length);\n}\n/**\n * A complete match of term in string is when term matches a complete word or\n * phrase in string and no partial words in string are left hanging off the\n * start or end. For example, if term is \"full\" and string is \"beautifully\", that\n * is not a complete match because \"beauti\" hangs off the beginning and \"y\" extends\n * before the start of the section of matching text.\n **/ function completeMatchBoundaries(string, startIndex, segmenter, term) {\n    // initialize values for output\n    // this is the output as it should be if no match is found\n    let matchBoundaries = {\n        naiveMatch: false,\n        completeMatch: false,\n        naiveMatchStart: -1,\n        naiveMatchEnd: -1,\n        completeMatchStart: -1,\n        completeMatchEnd: -1\n    };\n    // find a match by simple string search, starting at startIndex.\n    let unsearchedPartOfString = string.substring(startIndex);\n    let matchIndex = unsearchedPartOfString.indexOf(term) + startIndex;\n    // if no simple match was found, return\n    if (matchIndex < startIndex) return matchBoundaries;\n    // if we reach this point then a naive match was found.\n    // update naive match boundary information accordingly.\n    matchBoundaries.naiveMatch = true;\n    matchBoundaries.naiveMatchStart = matchIndex;\n    matchBoundaries.naiveMatchEnd = matchIndex + term.length - 1;\n    // segment the string\n    let stringSegments = segmenter.segment(string);\n    // get the string segment that contains the match index.\n    // this is the first word in string that matches term\n    let firstMatchingSegment = stringSegments.containing(matchIndex);\n    // if the index of the matching segment doesn't match the matchIndex found\n    // by naive search, it's a partial match. Return the boundary info as-is\n    // without complete match data.\n    if (firstMatchingSegment.index < matchIndex) return matchBoundaries;\n    /**\n   * at this point we know that the first character in \"term\" is the first\n   * character of a segment in string. now we need to check if the last character\n   * in \"term\" is also aligned with the last character of a segment in string.\n   **/ // get the string segment that contains the last character of term\n    let lastMatchingSegment = stringSegments.containing(matchBoundaries.naiveMatchEnd);\n    // get the index of the last character of that string segment\n    let endOfLastMatchingSegment = lastMatchingSegment.index + lastMatchingSegment.segment.length - 1;\n    // if the end of the last matching segment matches with the end of the naive \"indexOf\"\n    // match then the match is a complete match with no extra word characters hanging\n    // off the start or end.\n    if (endOfLastMatchingSegment == matchBoundaries.naiveMatchEnd) {\n        // update the complete match boundary info\n        matchBoundaries.completeMatch = true;\n        matchBoundaries.completeMatchStart = firstMatchingSegment.index;\n        matchBoundaries.completeMatchEnd = endOfLastMatchingSegment;\n    }\n    return matchBoundaries;\n}\n/**\n * Searches \"string\" for terms in \"glossary\" and gives the location where each term appears. If several glossary terms overlap, matching on the same words then the longest term takes precedence.\n *\n * @param string - the text string in which we want to search for glossary terms\n * @param glossary - an array of text strings, all the terms in the glossary. This list may contain several thousand items.\n * @param languageCode - ISO 639-1 language code\n * @returns {array} - a list of pairs [index, term] where int is the index at which term appears in string.\n **/ function glossaryMatches(string, allGlossary) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, textInfo = arguments.length > 3 ? arguments[3] : void 0, originalTermList = arguments.length > 4 ? arguments[4] : void 0;\n    // make a copy of string so that the original is not lost when we modify it\n    let stringCopy = string;\n    // if the search is not case-sensitive, convert everything to lower case\n    if (!caseSensitive) {\n        string = string.toLowerCase();\n    }\n    // split the string into segments, separating by word\n    let segmenter = new Intl.Segmenter(textInfo.language, {\n        granularity: \"word\"\n    });\n    let output = Array(0);\n    // for each list of terms in the sorted glossary\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.srcGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].sourceLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.targetGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].targetLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    // sort the output by the indices and return\n    return output.sort((a, b)=>a[0] - b[0]);\n}\nconst detectGlossary = (text, glossary, textInfo, originalTermList)=>{\n    let caseSensitive = false;\n    if (text) {\n        return glossaryMatches(text, glossary, caseSensitive, textInfo, originalTermList);\n    } else {\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QztRQUVKO0lBQ0YsRUFBRTtJQUVGLDRDQUE0QztJQUM1QyxPQUFPNEQsT0FBT2pDLElBQUksQ0FBQyxDQUFDQyxHQUFHaEIsSUFBTWdCLENBQUMsQ0FBQyxFQUFFLEdBQUdoQixDQUFDLENBQUMsRUFBRTtBQUMxQztBQUVPLE1BQU12QixpQkFBaUIsQ0FBQ1QsTUFBTUksVUFBVXNFLFVBQVVyRSxtQkFBcUI7SUFDNUUsSUFBSW9FLGdCQUFnQixLQUFLO0lBRXpCLElBQUl6RSxNQUFNO1FBQ1IsT0FBT3VFLGdCQUNMdkUsTUFDQUksVUFDQXFFLGVBQ0FDLFVBQ0FyRTtJQUVKLE9BQU87UUFDTCxPQUFPLEVBQUU7SUFDWCxDQUFDO0FBQ0gsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9nbG9zc2FyeVV0aWxzLmpzPzhkODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVwbGFjZVRleHRBdEluZGV4IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcblxuY29uc3QgcmVwbGFjZW1lbnRDb2RlID0gXCJYeGNENUpaNzNQRGdNNFBCRFdZdGZLTUtBYWtTdVJzR1wiO1xuXG5mdW5jdGlvbiByZXBsYWNlbWVudEZ1bmN0aW9uKG0pIHtcbiAgcmV0dXJuIHJlcGxhY2VtZW50Q29kZS5yZXBlYXQobS5sZW5ndGgpO1xufVxuXG5jb25zdCByZXBsYWNlVGV4dFdpdGhHbG9zc2FyeSA9IChcbiAgdGV4dCxcbiAgdGVybU1hdGNoR2xvc3NhcnksXG4gIHRlcm1MaXN0LFxuICBzb3VyY2VDZWxsLFxuICBnbG9zc2FyeSxcbiAgb3JpZ2luYWxUZXJtTGlzdFxuKSA9PiB7XG4gIGxldCBuZXdUZXh0ID0gdGV4dDtcbiAgbGV0IGluY3JlYXNlZFRvb2x0aXAgPSAwO1xuXG4gIGNvbnN0IHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlID0gZGV0ZWN0R2xvc3NhcnkoXG4gICAgc291cmNlQ2VsbD8udmFsdWUsXG4gICAgZ2xvc3NhcnksXG4gICAgc291cmNlQ2VsbCxcbiAgICBvcmlnaW5hbFRlcm1MaXN0XG4gICk7XG4gIGlmICh0ZXh0ID09PSBcInN0cmluZyB2w6AgS2FiYmFsYWggY8O1aVwiKSB7XG4gICAgY29uc29sZS5sb2coXCJ3dXR0XCIsIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlKTtcbiAgfVxuXG4gIHRlcm1NYXRjaEdsb3NzYXJ5LmZvckVhY2goKFtpLCB0ZXJtTWF0Y2hdKSA9PiB7XG4gICAgbGV0IHRyYW5sYXRpb25PZlRlcm0sIHNvdXJjZU9mVGVybSwgdGVybU5vdGU7XG4gICAgbGV0IHNvdXJjZVRlcm1BcHBlYXIgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgdGVybSBvZiB0ZXJtTGlzdCkge1xuICAgICAgaWYgKFxuICAgICAgICB0ZXJtLnNvdXJjZVZhbHVlcy5zb21lKFxuICAgICAgICAgICh2YWx1ZSkgPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdGVybU1hdGNoLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRyYW5sYXRpb25PZlRlcm0gPSB0ZXJtLnRyYW5zbGF0aW9ucztcbiAgICAgICAgdGVybU5vdGUgPSB0ZXJtLm5vdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGVybS50cmFuc2xhdGlvbnMuc29tZShcbiAgICAgICAgICAodmFsdWUpID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHRlcm1NYXRjaC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBzb3VyY2VPZlRlcm0gPSB0ZXJtLnNvdXJjZVZhbHVlcztcbiAgICAgICAgdGVybU5vdGUgPSB0ZXJtLm5vdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXh0ID09PSBcInN0cmluZyB2w6AgS2FiYmFsYWggY8O1aVwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNvdXJjZU9mVGVybVwiLCBzb3VyY2VPZlRlcm0pO1xuICAgICAgY29uc29sZS5sb2coXCJzb3VyY2VDZWxsXCIsIHNvdXJjZUNlbGwpO1xuICAgICAgY29uc29sZS5sb2coXCJ0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZVwiLCB0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZSk7XG4gICAgfVxuICAgIHNvdXJjZVRlcm1BcHBlYXIgPSBzb3VyY2VPZlRlcm0/LnNvbWUoKHZhbHVlMikgPT5cbiAgICAgIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlPy5zb21lKFxuICAgICAgICAoW18sIHZhbHVlMV0pID0+IHZhbHVlMS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZTIudG9Mb3dlckNhc2UoKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCB0b29sdGlwQ29udGVudCA9IHJlbmRlclRvU3RyaW5nKFxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZ2xvc3NhcnktdG9vbHRpcFwiPlxuICAgICAgICB7dGVybU1hdGNofVxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0b29sdGlwXCI+XG4gICAgICAgICAgPGI+e3Rlcm1NYXRjaH08L2I+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0cmFuc2xhdGVWYWx1ZVwiPlxuICAgICAgICAgICAge3NvdXJjZU9mVGVybVxuICAgICAgICAgICAgICA/IHNvdXJjZU9mVGVybT8uam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgIDogdHJhbmxhdGlvbk9mVGVybT8uam9pbihcIiwgXCIpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibm90ZVwiPnt0ZXJtTm90ZX08L2Rpdj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9zcGFuPlxuICAgICk7XG5cbiAgICBpZiAoKHNvdXJjZU9mVGVybSAmJiBzb3VyY2VUZXJtQXBwZWFyKSB8fCAhc291cmNlT2ZUZXJtKSB7XG4gICAgICBuZXdUZXh0ID0gcmVwbGFjZVRleHRBdEluZGV4KFxuICAgICAgICBuZXdUZXh0LFxuICAgICAgICBpICsgaW5jcmVhc2VkVG9vbHRpcCxcbiAgICAgICAgdGVybU1hdGNoLmxlbmd0aCxcbiAgICAgICAgdG9vbHRpcENvbnRlbnRcbiAgICAgICk7XG4gICAgICBpbmNyZWFzZWRUb29sdGlwID1cbiAgICAgICAgaW5jcmVhc2VkVG9vbHRpcCArIHRvb2x0aXBDb250ZW50Lmxlbmd0aCAtIHRlcm1NYXRjaC5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3VGV4dDtcbn07XG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheUFzSFRNTChcbiAgdGV4dEFyZWFUZXh0LFxuICB0ZXJtTWF0Y2hHbG9zc2FyeSxcbiAgdGVybUxpc3QsXG4gIHNvdXJjZUNlbGwsXG4gIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlLFxuICBvcmlnaW5hbFRlcm1MaXN0XG4pIHtcbiAgbGV0IHRleHRXaXRoR2xvc3NhcnkgPSByZXBsYWNlVGV4dFdpdGhHbG9zc2FyeShcbiAgICB0ZXh0QXJlYVRleHQsXG4gICAgdGVybU1hdGNoR2xvc3NhcnksXG4gICAgdGVybUxpc3QsXG4gICAgc291cmNlQ2VsbCxcbiAgICB0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZSxcbiAgICBvcmlnaW5hbFRlcm1MaXN0XG4gICk7XG5cbiAgbGV0IHRleHRXaXRoU3BhY2VzQmVmb3JlUHVuY3R1YXRpb25SZXBsYWNlZCA9IHRleHRXaXRoR2xvc3NhcnkucmVwbGFjZShcbiAgICAvICsoPz1bXFwuXFwhXFw/XSkvZyxcbiAgICByZXBsYWNlbWVudEZ1bmN0aW9uXG4gICk7XG5cbiAgLy8gYsO0aSDEkWVuIG5o4buvbmcgY2jhu5cgY8OzIGjGoW4gaGFpIGThuqV1IGPDoWNoIGxp4buBbi5cbiAgbGV0IHRleHRXaXRoU3BhY2VzUmVwbGFjZWQgPSB0ZXh0V2l0aFNwYWNlc0JlZm9yZVB1bmN0dWF0aW9uUmVwbGFjZWQucmVwbGFjZShcbiAgICAvKD88PSApICsvZyxcbiAgICByZXBsYWNlbWVudEZ1bmN0aW9uXG4gICk7XG5cbiAgLy8ga2hpIG7DoG8gZOG6pXUgY8OhY2ggdGjhu6thIHh14bqldCBoaeG7h24gbmdheSBzYXUgZOG6pXUgLiA/ICEsIG3DrG5oIHRoYXkgdGjhur8gZOG6pXUg4o61IMSR4bqndSB0acOqbiBi4bqxbmcgJm5ic3A7IMSR4buDIGNobyBwaMOpcCB1c2VyIGPDsyBoYWkgZOG6pXUgY8OhY2ggc2F1IC4gPyAhLlxuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoXCIoPzw9Wy4/IV0pIFwiICsgcmVwbGFjZW1lbnRDb2RlLCBcImdcIik7XG4gIGxldCB0ZXh0QWxsb3dpbmdEb3VibGVTcGFjZUFmdGVyRW5kT2ZTZW50ZW5jZSA9XG4gICAgdGV4dFdpdGhTcGFjZXNSZXBsYWNlZC5yZXBsYWNlKHJlZ2V4LCBcIiAmbmJzcDtcIik7XG5cbiAgLy8gdGhheSB0aOG6vyBjw6FjIGThuqV1IGPDoWNoIHRo4burYSBi4bqxbmcgZOG6pXUg4o61IG3DoHUgZOG7j1xuICBsZXQgdGV4dFdpdGhTcGFjZXNBc1VuZGVyc2NvcmVzID1cbiAgICB0ZXh0QWxsb3dpbmdEb3VibGVTcGFjZUFmdGVyRW5kT2ZTZW50ZW5jZS5yZXBsYWNlQWxsKFxuICAgICAgcmVwbGFjZW1lbnRDb2RlLFxuICAgICAgXCI8Zm9udCBjb2xvcj0jRjAwPuKOtTwvZm9udD5cIlxuICAgICk7XG5cbiAgcmV0dXJuIHRleHRXaXRoU3BhY2VzQXNVbmRlcnNjb3Jlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRHbG9zc2FyeUxpc3QoZ2xvc3NhcnkpIHtcbiAgZ2xvc3NhcnkuZm9yRWFjaChmdW5jdGlvbiAodGVybSwgaSkge1xuICAgIGdsb3NzYXJ5W2ldID0gdGVybS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbiAgcmV0dXJuIGdsb3NzYXJ5LnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEEgY29tcGxldGUgbWF0Y2ggb2YgdGVybSBpbiBzdHJpbmcgaXMgd2hlbiB0ZXJtIG1hdGNoZXMgYSBjb21wbGV0ZSB3b3JkIG9yXG4gKiBwaHJhc2UgaW4gc3RyaW5nIGFuZCBubyBwYXJ0aWFsIHdvcmRzIGluIHN0cmluZyBhcmUgbGVmdCBoYW5naW5nIG9mZiB0aGVcbiAqIHN0YXJ0IG9yIGVuZC4gRm9yIGV4YW1wbGUsIGlmIHRlcm0gaXMgXCJmdWxsXCIgYW5kIHN0cmluZyBpcyBcImJlYXV0aWZ1bGx5XCIsIHRoYXRcbiAqIGlzIG5vdCBhIGNvbXBsZXRlIG1hdGNoIGJlY2F1c2UgXCJiZWF1dGlcIiBoYW5ncyBvZmYgdGhlIGJlZ2lubmluZyBhbmQgXCJ5XCIgZXh0ZW5kc1xuICogYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiBvZiBtYXRjaGluZyB0ZXh0LlxuICoqL1xuZnVuY3Rpb24gY29tcGxldGVNYXRjaEJvdW5kYXJpZXMoc3RyaW5nLCBzdGFydEluZGV4LCBzZWdtZW50ZXIsIHRlcm0pIHtcbiAgLy8gaW5pdGlhbGl6ZSB2YWx1ZXMgZm9yIG91dHB1dFxuICAvLyB0aGlzIGlzIHRoZSBvdXRwdXQgYXMgaXQgc2hvdWxkIGJlIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gIGxldCBtYXRjaEJvdW5kYXJpZXMgPSB7XG4gICAgbmFpdmVNYXRjaDogZmFsc2UsXG4gICAgY29tcGxldGVNYXRjaDogZmFsc2UsXG4gICAgbmFpdmVNYXRjaFN0YXJ0OiAtMSxcbiAgICBuYWl2ZU1hdGNoRW5kOiAtMSxcbiAgICBjb21wbGV0ZU1hdGNoU3RhcnQ6IC0xLFxuICAgIGNvbXBsZXRlTWF0Y2hFbmQ6IC0xLFxuICB9O1xuXG4gIC8vIGZpbmQgYSBtYXRjaCBieSBzaW1wbGUgc3RyaW5nIHNlYXJjaCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleC5cbiAgbGV0IHVuc2VhcmNoZWRQYXJ0T2ZTdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xuICBsZXQgbWF0Y2hJbmRleCA9IHVuc2VhcmNoZWRQYXJ0T2ZTdHJpbmcuaW5kZXhPZih0ZXJtKSArIHN0YXJ0SW5kZXg7XG5cbiAgLy8gaWYgbm8gc2ltcGxlIG1hdGNoIHdhcyBmb3VuZCwgcmV0dXJuXG4gIGlmIChtYXRjaEluZGV4IDwgc3RhcnRJbmRleCkgcmV0dXJuIG1hdGNoQm91bmRhcmllcztcblxuICAvLyBpZiB3ZSByZWFjaCB0aGlzIHBvaW50IHRoZW4gYSBuYWl2ZSBtYXRjaCB3YXMgZm91bmQuXG4gIC8vIHVwZGF0ZSBuYWl2ZSBtYXRjaCBib3VuZGFyeSBpbmZvcm1hdGlvbiBhY2NvcmRpbmdseS5cbiAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2ggPSB0cnVlO1xuICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaFN0YXJ0ID0gbWF0Y2hJbmRleDtcbiAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQgPSBtYXRjaEluZGV4ICsgdGVybS5sZW5ndGggLSAxO1xuXG4gIC8vIHNlZ21lbnQgdGhlIHN0cmluZ1xuICBsZXQgc3RyaW5nU2VnbWVudHMgPSBzZWdtZW50ZXIuc2VnbWVudChzdHJpbmcpO1xuXG4gIC8vIGdldCB0aGUgc3RyaW5nIHNlZ21lbnQgdGhhdCBjb250YWlucyB0aGUgbWF0Y2ggaW5kZXguXG4gIC8vIHRoaXMgaXMgdGhlIGZpcnN0IHdvcmQgaW4gc3RyaW5nIHRoYXQgbWF0Y2hlcyB0ZXJtXG4gIGxldCBmaXJzdE1hdGNoaW5nU2VnbWVudCA9IHN0cmluZ1NlZ21lbnRzLmNvbnRhaW5pbmcobWF0Y2hJbmRleCk7XG5cbiAgLy8gaWYgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBzZWdtZW50IGRvZXNuJ3QgbWF0Y2ggdGhlIG1hdGNoSW5kZXggZm91bmRcbiAgLy8gYnkgbmFpdmUgc2VhcmNoLCBpdCdzIGEgcGFydGlhbCBtYXRjaC4gUmV0dXJuIHRoZSBib3VuZGFyeSBpbmZvIGFzLWlzXG4gIC8vIHdpdGhvdXQgY29tcGxldGUgbWF0Y2ggZGF0YS5cbiAgaWYgKGZpcnN0TWF0Y2hpbmdTZWdtZW50LmluZGV4IDwgbWF0Y2hJbmRleCkgcmV0dXJuIG1hdGNoQm91bmRhcmllcztcblxuICAvKipcbiAgICogYXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBcInRlcm1cIiBpcyB0aGUgZmlyc3RcbiAgICogY2hhcmFjdGVyIG9mIGEgc2VnbWVudCBpbiBzdHJpbmcuIG5vdyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgKiBpbiBcInRlcm1cIiBpcyBhbHNvIGFsaWduZWQgd2l0aCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSBzZWdtZW50IGluIHN0cmluZy5cbiAgICoqL1xuXG4gIC8vIGdldCB0aGUgc3RyaW5nIHNlZ21lbnQgdGhhdCBjb250YWlucyB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGVybVxuICBsZXQgbGFzdE1hdGNoaW5nU2VnbWVudCA9IHN0cmluZ1NlZ21lbnRzLmNvbnRhaW5pbmcoXG4gICAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmRcbiAgKTtcblxuICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGF0IHN0cmluZyBzZWdtZW50XG4gIGxldCBlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQgPVxuICAgIGxhc3RNYXRjaGluZ1NlZ21lbnQuaW5kZXggKyBsYXN0TWF0Y2hpbmdTZWdtZW50LnNlZ21lbnQubGVuZ3RoIC0gMTtcblxuICAvLyBpZiB0aGUgZW5kIG9mIHRoZSBsYXN0IG1hdGNoaW5nIHNlZ21lbnQgbWF0Y2hlcyB3aXRoIHRoZSBlbmQgb2YgdGhlIG5haXZlIFwiaW5kZXhPZlwiXG4gIC8vIG1hdGNoIHRoZW4gdGhlIG1hdGNoIGlzIGEgY29tcGxldGUgbWF0Y2ggd2l0aCBubyBleHRyYSB3b3JkIGNoYXJhY3RlcnMgaGFuZ2luZ1xuICAvLyBvZmYgdGhlIHN0YXJ0IG9yIGVuZC5cbiAgaWYgKGVuZE9mTGFzdE1hdGNoaW5nU2VnbWVudCA9PSBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaEVuZCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgY29tcGxldGUgbWF0Y2ggYm91bmRhcnkgaW5mb1xuICAgIG1hdGNoQm91bmRhcmllcy5jb21wbGV0ZU1hdGNoID0gdHJ1ZTtcbiAgICBtYXRjaEJvdW5kYXJpZXMuY29tcGxldGVNYXRjaFN0YXJ0ID0gZmlyc3RNYXRjaGluZ1NlZ21lbnQuaW5kZXg7XG4gICAgbWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2hFbmQgPSBlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQ7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hCb3VuZGFyaWVzO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIFwic3RyaW5nXCIgZm9yIHRlcm1zIGluIFwiZ2xvc3NhcnlcIiBhbmQgZ2l2ZXMgdGhlIGxvY2F0aW9uIHdoZXJlIGVhY2ggdGVybSBhcHBlYXJzLiBJZiBzZXZlcmFsIGdsb3NzYXJ5IHRlcm1zIG92ZXJsYXAsIG1hdGNoaW5nIG9uIHRoZSBzYW1lIHdvcmRzIHRoZW4gdGhlIGxvbmdlc3QgdGVybSB0YWtlcyBwcmVjZWRlbmNlLlxuICpcbiAqIEBwYXJhbSBzdHJpbmcgLSB0aGUgdGV4dCBzdHJpbmcgaW4gd2hpY2ggd2Ugd2FudCB0byBzZWFyY2ggZm9yIGdsb3NzYXJ5IHRlcm1zXG4gKiBAcGFyYW0gZ2xvc3NhcnkgLSBhbiBhcnJheSBvZiB0ZXh0IHN0cmluZ3MsIGFsbCB0aGUgdGVybXMgaW4gdGhlIGdsb3NzYXJ5LiBUaGlzIGxpc3QgbWF5IGNvbnRhaW4gc2V2ZXJhbCB0aG91c2FuZCBpdGVtcy5cbiAqIEBwYXJhbSBsYW5ndWFnZUNvZGUgLSBJU08gNjM5LTEgbGFuZ3VhZ2UgY29kZVxuICogQHJldHVybnMge2FycmF5fSAtIGEgbGlzdCBvZiBwYWlycyBbaW5kZXgsIHRlcm1dIHdoZXJlIGludCBpcyB0aGUgaW5kZXggYXQgd2hpY2ggdGVybSBhcHBlYXJzIGluIHN0cmluZy5cbiAqKi9cbmZ1bmN0aW9uIGdsb3NzYXJ5TWF0Y2hlcyhcbiAgc3RyaW5nLFxuICBhbGxHbG9zc2FyeSxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICB0ZXh0SW5mbyxcbiAgb3JpZ2luYWxUZXJtTGlzdFxuKSB7XG4gIC8vIG1ha2UgYSBjb3B5IG9mIHN0cmluZyBzbyB0aGF0IHRoZSBvcmlnaW5hbCBpcyBub3QgbG9zdCB3aGVuIHdlIG1vZGlmeSBpdFxuICBsZXQgc3RyaW5nQ29weSA9IHN0cmluZztcbiAgLy8gaWYgdGhlIHNlYXJjaCBpcyBub3QgY2FzZS1zZW5zaXRpdmUsIGNvbnZlcnQgZXZlcnl0aGluZyB0byBsb3dlciBjYXNlXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy8gc3BsaXQgdGhlIHN0cmluZyBpbnRvIHNlZ21lbnRzLCBzZXBhcmF0aW5nIGJ5IHdvcmRcbiAgbGV0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcih0ZXh0SW5mby5sYW5ndWFnZSwge1xuICAgIGdyYW51bGFyaXR5OiBcIndvcmRcIixcbiAgfSk7XG5cbiAgbGV0IG91dHB1dCA9IEFycmF5KDApO1xuXG4gIC8vIGZvciBlYWNoIGxpc3Qgb2YgdGVybXMgaW4gdGhlIHNvcnRlZCBnbG9zc2FyeVxuICBhbGxHbG9zc2FyeT8uc3JjR2xvc3NhcnkuZm9yRWFjaChmdW5jdGlvbiAodGVybSkge1xuICAgIC8vIHdlIHN0YXJ0IHNlYXJjaGluZyBmb3IgXCJ0ZXJtXCIgc3RhcnRpbmcgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIFwic3RyaW5nXCJcbiAgICBsZXQgc2VhcmNoU3RhcnRJbmRleCA9IDA7XG5cbiAgICAvLyBmaW5kIHRoZSBsb2NhdGlvbiBpbiBcInN0cmluZ1wiIHdoZXJlIHRoZSBcInRlcm1cIiBpcyBmb3VuZFxuICAgIGxldCBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgIHN0cmluZyxcbiAgICAgIHNlYXJjaFN0YXJ0SW5kZXgsXG4gICAgICBzZWdtZW50ZXIsXG4gICAgICB0ZXJtXG4gICAgKTtcblxuICAgIC8vIGlmIFwidGVybVwiIHdhcyBmb3VuZCBpbiBcInN0cmluZ1wiIGJ5IG5haXZlIGluZGV4T2Ygc2VhcmNoXG4gICAgd2hpbGUgKFxuICAgICAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2ggJiZcbiAgICAgIHRleHRJbmZvLmxhbmd1YWdlID09PSBvcmlnaW5hbFRlcm1MaXN0WzBdLnNvdXJjZUxhbmd1YWdlXG4gICAgKSB7XG4gICAgICAvLyBzaW5jZSBhIG5haXZlIG1hdGNoIHdhcyBmb3VuZCwgd2UgdXBkYXRlIHRoZSBzZWFyY2hTdGFydEluZGV4IHRvIHByZXZlbnRcbiAgICAgIC8vIGZpbmRpbmcgdGhhdCBzYW1lIG5haXZlIG1hdGNoIGFnYWluIGluIHRoZSBmdXR1cmUuXG4gICAgICBzZWFyY2hTdGFydEluZGV4ID0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQgKyAxO1xuXG4gICAgICAvLyBpZiB0aGUgbWF0Y2ggaXMgYSBjb21wbGV0ZSBtYXRjaCwgcmVjb3JkIGl0LCB0aGVuIGVyYXNlIGl0IGZyb20gc3RyaW5nIHRvXG4gICAgICAvLyBwcmV2ZW50IHNob3J0ZXIgdGVybXMgZnJvbSBkb3VibGUtbWF0Y2hpbmcgb24gaXQgbGF0ZXIgb24uXG4gICAgICBpZiAobWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgICAgLy8gZ2V0IGEgc2hvcnRlciB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kZXggd2hlcmUgdGhlIG5haXZlIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICBsZXQgbWF0Y2hJbmRleCA9IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoU3RhcnQ7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCB0ZXJtIGZyb20gdGhlIGNvcHkgb2Ygc3RyaW5nLCBpbiBjYXNlIHRoZSBjYXNlLWluc2VudGl0aXZlXG4gICAgICAgIC8vIHNlYXJjaCBjYXVzZWQgdGhlIHN0cmluZyB0byBiZSBtb2RpZmllZFxuICAgICAgICBsZXQgb3JpZ2luYWxUZXJtID0gc3RyaW5nQ29weS5zdWJzdHJpbmcoXG4gICAgICAgICAgbWF0Y2hJbmRleCxcbiAgICAgICAgICBtYXRjaEluZGV4ICsgdGVybS5sZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHRlcm0gdG8gdGhlIG91dHB1dCBsaXN0XG4gICAgICAgIG91dHB1dC5wdXNoKFttYXRjaEluZGV4LCBvcmlnaW5hbFRlcm1dKTtcblxuICAgICAgICAvLyBFcmFzZSB0aGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzIGluIHN0cmluZyBzbyB0aGF0IHN1YnNlcXVlbnRcbiAgICAgICAgLy8gdGVybXMgaW4gdGhlIGdsb3NzYXJ5IGNhbid0IG1hdGNoIHdpdGggdGhlIHNhbWUgdGV4dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQmVjYXVzZSBvdXIgZ2xvc3NhcnkgaXMgc29ydGVkIHdpdGggbG9uZ2VzdCB0ZXJtcyBmaXJzdCxcbiAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgbG9uZ2VyIG1hdGNoZXMgdGFrZSBwcmVjZW5kZW5jZSBvdmVyIHNob3J0ZXJcbiAgICAgICAgLy8gb25lcy5cbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UodGVybSwgXCIgXCIucmVwZWF0KHRlcm0ubGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgb3RoZXIgcGxhY2VzIGluIFwic3RyaW5nXCIgdGhhdCBtYXRjaCBcInRlcm1cIi5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSwgdGhlIHdoaWxlIGxvb3Agd2lsbCByZXBlYXQuXG4gICAgICBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICBzZWFyY2hTdGFydEluZGV4LFxuICAgICAgICBzZWdtZW50ZXIsXG4gICAgICAgIHRlcm1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBhbGxHbG9zc2FyeT8udGFyZ2V0R2xvc3NhcnkuZm9yRWFjaChmdW5jdGlvbiAodGVybSkge1xuICAgIC8vIHdlIHN0YXJ0IHNlYXJjaGluZyBmb3IgXCJ0ZXJtXCIgc3RhcnRpbmcgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIFwic3RyaW5nXCJcbiAgICBsZXQgc2VhcmNoU3RhcnRJbmRleCA9IDA7XG5cbiAgICAvLyBmaW5kIHRoZSBsb2NhdGlvbiBpbiBcInN0cmluZ1wiIHdoZXJlIHRoZSBcInRlcm1cIiBpcyBmb3VuZFxuICAgIGxldCBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgIHN0cmluZyxcbiAgICAgIHNlYXJjaFN0YXJ0SW5kZXgsXG4gICAgICBzZWdtZW50ZXIsXG4gICAgICB0ZXJtXG4gICAgKTtcblxuICAgIC8vIGlmIFwidGVybVwiIHdhcyBmb3VuZCBpbiBcInN0cmluZ1wiIGJ5IG5haXZlIGluZGV4T2Ygc2VhcmNoXG4gICAgd2hpbGUgKFxuICAgICAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2ggJiZcbiAgICAgIHRleHRJbmZvLmxhbmd1YWdlID09PSBvcmlnaW5hbFRlcm1MaXN0WzBdLnRhcmdldExhbmd1YWdlXG4gICAgKSB7XG4gICAgICAvLyBzaW5jZSBhIG5haXZlIG1hdGNoIHdhcyBmb3VuZCwgd2UgdXBkYXRlIHRoZSBzZWFyY2hTdGFydEluZGV4IHRvIHByZXZlbnRcbiAgICAgIC8vIGZpbmRpbmcgdGhhdCBzYW1lIG5haXZlIG1hdGNoIGFnYWluIGluIHRoZSBmdXR1cmUuXG4gICAgICBzZWFyY2hTdGFydEluZGV4ID0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQgKyAxO1xuXG4gICAgICAvLyBpZiB0aGUgbWF0Y2ggaXMgYSBjb21wbGV0ZSBtYXRjaCwgcmVjb3JkIGl0LCB0aGVuIGVyYXNlIGl0IGZyb20gc3RyaW5nIHRvXG4gICAgICAvLyBwcmV2ZW50IHNob3J0ZXIgdGVybXMgZnJvbSBkb3VibGUtbWF0Y2hpbmcgb24gaXQgbGF0ZXIgb24uXG4gICAgICBpZiAobWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgICAgLy8gZ2V0IGEgc2hvcnRlciB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kZXggd2hlcmUgdGhlIG5haXZlIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICBsZXQgbWF0Y2hJbmRleCA9IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoU3RhcnQ7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCB0ZXJtIGZyb20gdGhlIGNvcHkgb2Ygc3RyaW5nLCBpbiBjYXNlIHRoZSBjYXNlLWluc2VudGl0aXZlXG4gICAgICAgIC8vIHNlYXJjaCBjYXVzZWQgdGhlIHN0cmluZyB0byBiZSBtb2RpZmllZFxuICAgICAgICBsZXQgb3JpZ2luYWxUZXJtID0gc3RyaW5nQ29weS5zdWJzdHJpbmcoXG4gICAgICAgICAgbWF0Y2hJbmRleCxcbiAgICAgICAgICBtYXRjaEluZGV4ICsgdGVybS5sZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHRlcm0gdG8gdGhlIG91dHB1dCBsaXN0XG4gICAgICAgIG91dHB1dC5wdXNoKFttYXRjaEluZGV4LCBvcmlnaW5hbFRlcm1dKTtcblxuICAgICAgICAvLyBFcmFzZSB0aGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzIGluIHN0cmluZyBzbyB0aGF0IHN1YnNlcXVlbnRcbiAgICAgICAgLy8gdGVybXMgaW4gdGhlIGdsb3NzYXJ5IGNhbid0IG1hdGNoIHdpdGggdGhlIHNhbWUgdGV4dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQmVjYXVzZSBvdXIgZ2xvc3NhcnkgaXMgc29ydGVkIHdpdGggbG9uZ2VzdCB0ZXJtcyBmaXJzdCxcbiAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgbG9uZ2VyIG1hdGNoZXMgdGFrZSBwcmVjZW5kZW5jZSBvdmVyIHNob3J0ZXJcbiAgICAgICAgLy8gb25lcy5cbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UodGVybSwgXCIgXCIucmVwZWF0KHRlcm0ubGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgb3RoZXIgcGxhY2VzIGluIFwic3RyaW5nXCIgdGhhdCBtYXRjaCBcInRlcm1cIi5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSwgdGhlIHdoaWxlIGxvb3Agd2lsbCByZXBlYXQuXG4gICAgICBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICBzZWFyY2hTdGFydEluZGV4LFxuICAgICAgICBzZWdtZW50ZXIsXG4gICAgICAgIHRlcm1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvLyBzb3J0IHRoZSBvdXRwdXQgYnkgdGhlIGluZGljZXMgYW5kIHJldHVyblxuICByZXR1cm4gb3V0cHV0LnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcbn1cblxuZXhwb3J0IGNvbnN0IGRldGVjdEdsb3NzYXJ5ID0gKHRleHQsIGdsb3NzYXJ5LCB0ZXh0SW5mbywgb3JpZ2luYWxUZXJtTGlzdCkgPT4ge1xuICBsZXQgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlO1xuXG4gIGlmICh0ZXh0KSB7XG4gICAgcmV0dXJuIGdsb3NzYXJ5TWF0Y2hlcyhcbiAgICAgIHRleHQsXG4gICAgICBnbG9zc2FyeSxcbiAgICAgIGNhc2VTZW5zaXRpdmUsXG4gICAgICB0ZXh0SW5mbyxcbiAgICAgIG9yaWdpbmFsVGVybUxpc3RcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJyZXBsYWNlVGV4dEF0SW5kZXgiLCJyZW5kZXJUb1N0cmluZyIsInJlcGxhY2VtZW50Q29kZSIsInJlcGxhY2VtZW50RnVuY3Rpb24iLCJtIiwicmVwZWF0IiwibGVuZ3RoIiwicmVwbGFjZVRleHRXaXRoR2xvc3NhcnkiLCJ0ZXh0IiwidGVybU1hdGNoR2xvc3NhcnkiLCJ0ZXJtTGlzdCIsInNvdXJjZUNlbGwiLCJnbG9zc2FyeSIsIm9yaWdpbmFsVGVybUxpc3QiLCJuZXdUZXh0IiwiaW5jcmVhc2VkVG9vbHRpcCIsInRlcm1NYXRjaEdsb3NzYXJ5U291cmNlIiwiZGV0ZWN0R2xvc3NhcnkiLCJ2YWx1ZSIsImNvbnNvbGUiLCJsb2ciLCJmb3JFYWNoIiwiaSIsInRlcm1NYXRjaCIsInRyYW5sYXRpb25PZlRlcm0iLCJzb3VyY2VPZlRlcm0iLCJ0ZXJtTm90ZSIsInNvdXJjZVRlcm1BcHBlYXIiLCJ0ZXJtIiwic291cmNlVmFsdWVzIiwic29tZSIsInRvTG93ZXJDYXNlIiwidHJhbnNsYXRpb25zIiwibm90ZSIsInZhbHVlMiIsInZhbHVlMSIsIl8iLCJ0b29sdGlwQ29udGVudCIsInNwYW4iLCJjbGFzc05hbWUiLCJiIiwiZGl2Iiwiam9pbiIsImRpc3BsYXlBc0hUTUwiLCJ0ZXh0QXJlYVRleHQiLCJ0ZXh0V2l0aEdsb3NzYXJ5IiwidGV4dFdpdGhTcGFjZXNCZWZvcmVQdW5jdHVhdGlvblJlcGxhY2VkIiwicmVwbGFjZSIsInRleHRXaXRoU3BhY2VzUmVwbGFjZWQiLCJyZWdleCIsIlJlZ0V4cCIsInRleHRBbGxvd2luZ0RvdWJsZVNwYWNlQWZ0ZXJFbmRPZlNlbnRlbmNlIiwidGV4dFdpdGhTcGFjZXNBc1VuZGVyc2NvcmVzIiwicmVwbGFjZUFsbCIsInNvcnRHbG9zc2FyeUxpc3QiLCJzb3J0IiwiYSIsImNvbXBsZXRlTWF0Y2hCb3VuZGFyaWVzIiwic3RyaW5nIiwic3RhcnRJbmRleCIsInNlZ21lbnRlciIsIm1hdGNoQm91bmRhcmllcyIsIm5haXZlTWF0Y2giLCJjb21wbGV0ZU1hdGNoIiwibmFpdmVNYXRjaFN0YXJ0IiwibmFpdmVNYXRjaEVuZCIsImNvbXBsZXRlTWF0Y2hTdGFydCIsImNvbXBsZXRlTWF0Y2hFbmQiLCJ1bnNlYXJjaGVkUGFydE9mU3RyaW5nIiwic3Vic3RyaW5nIiwibWF0Y2hJbmRleCIsImluZGV4T2YiLCJzdHJpbmdTZWdtZW50cyIsInNlZ21lbnQiLCJmaXJzdE1hdGNoaW5nU2VnbWVudCIsImNvbnRhaW5pbmciLCJpbmRleCIsImxhc3RNYXRjaGluZ1NlZ21lbnQiLCJlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQiLCJnbG9zc2FyeU1hdGNoZXMiLCJhbGxHbG9zc2FyeSIsImNhc2VTZW5zaXRpdmUiLCJ0ZXh0SW5mbyIsInN0cmluZ0NvcHkiLCJJbnRsIiwiU2VnbWVudGVyIiwibGFuZ3VhZ2UiLCJncmFudWxhcml0eSIsIm91dHB1dCIsIkFycmF5Iiwic3JjR2xvc3NhcnkiLCJzZWFyY2hTdGFydEluZGV4Iiwic291cmNlTGFuZ3VhZ2UiLCJvcmlnaW5hbFRlcm0iLCJwdXNoIiwidGFyZ2V0R2xvc3NhcnkiLCJ0YXJnZXRMYW5ndWFnZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./utils/glossaryUtils.js\n"));

/***/ })

});
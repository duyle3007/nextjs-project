"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("pages/file/[id]",{

/***/ "./utils/glossaryUtils.js":
/*!********************************!*\
  !*** ./utils/glossaryUtils.js ***!
  \********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"detectGlossary\": function() { return /* binding */ detectGlossary; },\n/* harmony export */   \"displayAsHTML\": function() { return /* binding */ displayAsHTML; },\n/* harmony export */   \"sortGlossaryList\": function() { return /* binding */ sortGlossaryList; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./utils */ \"./utils/utils.js\");\n/* harmony import */ var react_dom_server__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-dom/server */ \"./node_modules/react-dom/server.browser.js\");\n\n\n\nconst replacementCode = \"XxcD5JZ73PDgM4PBDWYtfKMKAakSuRsG\";\nfunction replacementFunction(m) {\n    return replacementCode.repeat(m.length);\n}\nconst replaceTextWithGlossary = (text, termMatchGlossary, termList, sourceCell, glossary, originalTermList)=>{\n    let newText = text;\n    let increasedTooltip = 0;\n    termMatchGlossary.forEach((param)=>{\n        let [i, termMatch] = param;\n        let tranlationOfTerm, sourceOfTerm, termNote;\n        let sourceTermAppear = false;\n        for (const term of termList){\n            if (term.sourceValues.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                tranlationOfTerm = term.translations;\n                termNote = term.note;\n                break;\n            } else if (term.translations.some((value)=>value.toLowerCase() === termMatch.toLowerCase())) {\n                sourceOfTerm = term.sourceValues;\n                termNote = term.note;\n                break;\n            }\n        }\n        if (text === \"string v\\xe0 Kabbalah c\\xf5i\") {\n            console.log(\"sourceOfTerm\", sourceOfTerm);\n            console.log(\"sourceCell\", sourceCell);\n            console.log(\"termMatchGlossarySource\", termMatchGlossarySource);\n        }\n        sourceTermAppear = sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.some((value2)=>{\n            return termMatchGlossarySource === null || termMatchGlossarySource === void 0 ? void 0 : termMatchGlossarySource.some((param)=>{\n                let [_, value1] = param;\n                return value1.toLowerCase() === value2.toLowerCase();\n            });\n        });\n        const tooltipContent = (0,react_dom_server__WEBPACK_IMPORTED_MODULE_2__.renderToString)(/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n            className: \"glossary-tooltip\",\n            children: [\n                termMatch,\n                /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                    className: \"tooltip\",\n                    children: [\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"b\", {\n                            children: termMatch\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 60,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"translateValue\",\n                            children: sourceOfTerm ? sourceOfTerm === null || sourceOfTerm === void 0 ? void 0 : sourceOfTerm.join(\", \") : tranlationOfTerm === null || tranlationOfTerm === void 0 ? void 0 : tranlationOfTerm.join(\", \")\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 61,\n                            columnNumber: 11\n                        }, undefined),\n                        /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                            className: \"note\",\n                            children: termNote\n                        }, void 0, false, {\n                            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                            lineNumber: 66,\n                            columnNumber: 11\n                        }, undefined)\n                    ]\n                }, void 0, true, {\n                    fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n                    lineNumber: 59,\n                    columnNumber: 9\n                }, undefined)\n            ]\n        }, void 0, true, {\n            fileName: \"/Users/fetch/Documents/gnosis/utils/glossaryUtils.js\",\n            lineNumber: 57,\n            columnNumber: 7\n        }, undefined));\n        if (sourceOfTerm && sourceTermAppear || !sourceOfTerm) {\n            newText = (0,_utils__WEBPACK_IMPORTED_MODULE_1__.replaceTextAtIndex)(newText, i + increasedTooltip, termMatch.length, tooltipContent);\n            increasedTooltip = increasedTooltip + tooltipContent.length - termMatch.length;\n        }\n    });\n    return newText;\n};\nfunction displayAsHTML(textAreaText, termMatchGlossary, termList, sourceCell, termMatchGlossarySource1, originalTermList) {\n    let textWithGlossary = replaceTextWithGlossary(textAreaText, termMatchGlossary, termList, sourceCell, termMatchGlossarySource1, originalTermList);\n    let textWithSpacesBeforePunctuationReplaced = textWithGlossary.replace(/ +(?=[\\.\\!\\?])/g, replacementFunction);\n    // bôi đen những chỗ có hơn hai dấu cách liền.\n    let textWithSpacesReplaced = textWithSpacesBeforePunctuationReplaced.replace(RegExp(\"(?<= ) +\", \"g\"), replacementFunction);\n    // khi nào dấu cách thừa xuất hiện ngay sau dấu . ? !, mình thay thế dấu ⎵ đầu tiên bằng &nbsp; để cho phép user có hai dấu cách sau . ? !.\n    const regex = new RegExp(\"(?<=[.?!]) \" + replacementCode, \"g\");\n    let textAllowingDoubleSpaceAfterEndOfSentence = textWithSpacesReplaced.replace(regex, \" &nbsp;\");\n    // thay thế các dấu cách thừa bằng dấu ⎵ màu dỏ\n    let textWithSpacesAsUnderscores = textAllowingDoubleSpaceAfterEndOfSentence.replaceAll(replacementCode, \"<font color=#F00>⎵</font>\");\n    return textWithSpacesAsUnderscores;\n}\nfunction sortGlossaryList(glossary) {\n    glossary.forEach(function(term, i) {\n        glossary[i] = term.toLowerCase();\n    });\n    return glossary.sort((a, b)=>b.length - a.length);\n}\n/**\n * A complete match of term in string is when term matches a complete word or\n * phrase in string and no partial words in string are left hanging off the\n * start or end. For example, if term is \"full\" and string is \"beautifully\", that\n * is not a complete match because \"beauti\" hangs off the beginning and \"y\" extends\n * before the start of the section of matching text.\n **/ function completeMatchBoundaries(string, startIndex, segmenter, term) {\n    // initialize values for output\n    // this is the output as it should be if no match is found\n    let matchBoundaries = {\n        naiveMatch: false,\n        completeMatch: false,\n        naiveMatchStart: -1,\n        naiveMatchEnd: -1,\n        completeMatchStart: -1,\n        completeMatchEnd: -1\n    };\n    // find a match by simple string search, starting at startIndex.\n    let unsearchedPartOfString = string.substring(startIndex);\n    let matchIndex = unsearchedPartOfString.indexOf(term) + startIndex;\n    // if no simple match was found, return\n    if (matchIndex < startIndex) return matchBoundaries;\n    // if we reach this point then a naive match was found.\n    // update naive match boundary information accordingly.\n    matchBoundaries.naiveMatch = true;\n    matchBoundaries.naiveMatchStart = matchIndex;\n    matchBoundaries.naiveMatchEnd = matchIndex + term.length - 1;\n    // segment the string\n    let stringSegments = segmenter.segment(string);\n    // get the string segment that contains the match index.\n    // this is the first word in string that matches term\n    let firstMatchingSegment = stringSegments.containing(matchIndex);\n    // if the index of the matching segment doesn't match the matchIndex found\n    // by naive search, it's a partial match. Return the boundary info as-is\n    // without complete match data.\n    if (firstMatchingSegment.index < matchIndex) return matchBoundaries;\n    /**\n   * at this point we know that the first character in \"term\" is the first\n   * character of a segment in string. now we need to check if the last character\n   * in \"term\" is also aligned with the last character of a segment in string.\n   **/ // get the string segment that contains the last character of term\n    let lastMatchingSegment = stringSegments.containing(matchBoundaries.naiveMatchEnd);\n    // get the index of the last character of that string segment\n    let endOfLastMatchingSegment = lastMatchingSegment.index + lastMatchingSegment.segment.length - 1;\n    // if the end of the last matching segment matches with the end of the naive \"indexOf\"\n    // match then the match is a complete match with no extra word characters hanging\n    // off the start or end.\n    if (endOfLastMatchingSegment == matchBoundaries.naiveMatchEnd) {\n        // update the complete match boundary info\n        matchBoundaries.completeMatch = true;\n        matchBoundaries.completeMatchStart = firstMatchingSegment.index;\n        matchBoundaries.completeMatchEnd = endOfLastMatchingSegment;\n    }\n    return matchBoundaries;\n}\n/**\n * Searches \"string\" for terms in \"glossary\" and gives the location where each term appears. If several glossary terms overlap, matching on the same words then the longest term takes precedence.\n *\n * @param string - the text string in which we want to search for glossary terms\n * @param glossary - an array of text strings, all the terms in the glossary. This list may contain several thousand items.\n * @param languageCode - ISO 639-1 language code\n * @returns {array} - a list of pairs [index, term] where int is the index at which term appears in string.\n **/ function glossaryMatches(string, allGlossary) {\n    let caseSensitive = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false, textInfo = arguments.length > 3 ? arguments[3] : void 0, originalTermList = arguments.length > 4 ? arguments[4] : void 0;\n    // make a copy of string so that the original is not lost when we modify it\n    let stringCopy = string;\n    // if the search is not case-sensitive, convert everything to lower case\n    if (!caseSensitive) {\n        string = string.toLowerCase();\n    }\n    // split the string into segments, separating by word\n    let segmenter = new Intl.Segmenter(textInfo.language, {\n        granularity: \"word\"\n    });\n    let output = Array(0);\n    // for each list of terms in the sorted glossary\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.srcGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].sourceLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    allGlossary === null || allGlossary === void 0 ? void 0 : allGlossary.targetGlossary.forEach(function(term) {\n        // we start searching for \"term\" starting from the beginning of \"string\"\n        let searchStartIndex = 0;\n        // find the location in \"string\" where the \"term\" is found\n        let matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        // if \"term\" was found in \"string\" by naive indexOf search\n        while(matchBoundaries.naiveMatch && textInfo.language === originalTermList[0].targetLanguage){\n            // since a naive match was found, we update the searchStartIndex to prevent\n            // finding that same naive match again in the future.\n            searchStartIndex = matchBoundaries.naiveMatchEnd + 1;\n            // if the match is a complete match, record it, then erase it from string to\n            // prevent shorter terms from double-matching on it later on.\n            if (matchBoundaries.completeMatch) {\n                // get a shorter variable name for the index where the naive match was found\n                let matchIndex = matchBoundaries.naiveMatchStart;\n                // get the original term from the copy of string, in case the case-insentitive\n                // search caused the string to be modified\n                let originalTerm = stringCopy.substring(matchIndex, matchIndex + term.length);\n                // add the term to the output list\n                output.push([\n                    matchIndex,\n                    originalTerm\n                ]);\n                // Erase the corresponding characters in string so that subsequent\n                // terms in the glossary can't match with the same text.\n                //\n                // Because our glossary is sorted with longest terms first,\n                // this ensures that longer matches take precendence over shorter\n                // ones.\n                string = string.replace(term, \" \".repeat(term.length));\n            }\n            // check to see if there are other places in \"string\" that match \"term\".\n            // If there are, the while loop will repeat.\n            matchBoundaries = completeMatchBoundaries(string, searchStartIndex, segmenter, term);\n        }\n    });\n    // sort the output by the indices and return\n    return output.sort((a, b)=>a[0] - b[0]);\n}\nconst detectGlossary = (text, glossary, textInfo, originalTermList, termSourceMatchGlossary)=>{\n    let caseSensitive = false;\n    if (text) {\n        return glossaryMatches(text, glossary, caseSensitive, textInfo, originalTermList, termSourceMatchGlossary);\n    } else {\n        return [];\n    }\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUM1QnhGLE1BQ0FJLFVBQ0FxRSxVQUNBcEUsa0JBQ0FvRiwwQkFDRztJQUNILElBQUlqQixnQkFBZ0IsS0FBSztJQUV6QixJQUFJeEUsTUFBTTtRQUNSLE9BQU9zRSxnQkFDTHRFLE1BQ0FJLFVBQ0FvRSxlQUNBQyxVQUNBcEUsa0JBQ0FvRjtJQUVKLE9BQU87UUFDTCxPQUFPLEVBQUU7SUFDWCxDQUFDO0FBQ0gsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi91dGlscy9nbG9zc2FyeVV0aWxzLmpzPzhkODciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgcmVwbGFjZVRleHRBdEluZGV4IH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCB7IHJlbmRlclRvU3RyaW5nIH0gZnJvbSBcInJlYWN0LWRvbS9zZXJ2ZXJcIjtcblxuY29uc3QgcmVwbGFjZW1lbnRDb2RlID0gXCJYeGNENUpaNzNQRGdNNFBCRFdZdGZLTUtBYWtTdVJzR1wiO1xuXG5mdW5jdGlvbiByZXBsYWNlbWVudEZ1bmN0aW9uKG0pIHtcbiAgcmV0dXJuIHJlcGxhY2VtZW50Q29kZS5yZXBlYXQobS5sZW5ndGgpO1xufVxuXG5jb25zdCByZXBsYWNlVGV4dFdpdGhHbG9zc2FyeSA9IChcbiAgdGV4dCxcbiAgdGVybU1hdGNoR2xvc3NhcnksXG4gIHRlcm1MaXN0LFxuICBzb3VyY2VDZWxsLFxuICBnbG9zc2FyeSxcbiAgb3JpZ2luYWxUZXJtTGlzdFxuKSA9PiB7XG4gIGxldCBuZXdUZXh0ID0gdGV4dDtcbiAgbGV0IGluY3JlYXNlZFRvb2x0aXAgPSAwO1xuXG4gIHRlcm1NYXRjaEdsb3NzYXJ5LmZvckVhY2goKFtpLCB0ZXJtTWF0Y2hdKSA9PiB7XG4gICAgbGV0IHRyYW5sYXRpb25PZlRlcm0sIHNvdXJjZU9mVGVybSwgdGVybU5vdGU7XG4gICAgbGV0IHNvdXJjZVRlcm1BcHBlYXIgPSBmYWxzZTtcblxuICAgIGZvciAoY29uc3QgdGVybSBvZiB0ZXJtTGlzdCkge1xuICAgICAgaWYgKFxuICAgICAgICB0ZXJtLnNvdXJjZVZhbHVlcy5zb21lKFxuICAgICAgICAgICh2YWx1ZSkgPT4gdmFsdWUudG9Mb3dlckNhc2UoKSA9PT0gdGVybU1hdGNoLnRvTG93ZXJDYXNlKClcbiAgICAgICAgKVxuICAgICAgKSB7XG4gICAgICAgIHRyYW5sYXRpb25PZlRlcm0gPSB0ZXJtLnRyYW5zbGF0aW9ucztcbiAgICAgICAgdGVybU5vdGUgPSB0ZXJtLm5vdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgdGVybS50cmFuc2xhdGlvbnMuc29tZShcbiAgICAgICAgICAodmFsdWUpID0+IHZhbHVlLnRvTG93ZXJDYXNlKCkgPT09IHRlcm1NYXRjaC50b0xvd2VyQ2FzZSgpXG4gICAgICAgIClcbiAgICAgICkge1xuICAgICAgICBzb3VyY2VPZlRlcm0gPSB0ZXJtLnNvdXJjZVZhbHVlcztcbiAgICAgICAgdGVybU5vdGUgPSB0ZXJtLm5vdGU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0ZXh0ID09PSBcInN0cmluZyB2w6AgS2FiYmFsYWggY8O1aVwiKSB7XG4gICAgICBjb25zb2xlLmxvZyhcInNvdXJjZU9mVGVybVwiLCBzb3VyY2VPZlRlcm0pO1xuICAgICAgY29uc29sZS5sb2coXCJzb3VyY2VDZWxsXCIsIHNvdXJjZUNlbGwpO1xuICAgICAgY29uc29sZS5sb2coXCJ0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZVwiLCB0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZSk7XG4gICAgfVxuICAgIHNvdXJjZVRlcm1BcHBlYXIgPSBzb3VyY2VPZlRlcm0/LnNvbWUoKHZhbHVlMikgPT5cbiAgICAgIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlPy5zb21lKFxuICAgICAgICAoW18sIHZhbHVlMV0pID0+IHZhbHVlMS50b0xvd2VyQ2FzZSgpID09PSB2YWx1ZTIudG9Mb3dlckNhc2UoKVxuICAgICAgKVxuICAgICk7XG5cbiAgICBjb25zdCB0b29sdGlwQ29udGVudCA9IHJlbmRlclRvU3RyaW5nKFxuICAgICAgPHNwYW4gY2xhc3NOYW1lPVwiZ2xvc3NhcnktdG9vbHRpcFwiPlxuICAgICAgICB7dGVybU1hdGNofVxuICAgICAgICA8c3BhbiBjbGFzc05hbWU9XCJ0b29sdGlwXCI+XG4gICAgICAgICAgPGI+e3Rlcm1NYXRjaH08L2I+XG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJ0cmFuc2xhdGVWYWx1ZVwiPlxuICAgICAgICAgICAge3NvdXJjZU9mVGVybVxuICAgICAgICAgICAgICA/IHNvdXJjZU9mVGVybT8uam9pbihcIiwgXCIpXG4gICAgICAgICAgICAgIDogdHJhbmxhdGlvbk9mVGVybT8uam9pbihcIiwgXCIpfVxuICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwibm90ZVwiPnt0ZXJtTm90ZX08L2Rpdj5cbiAgICAgICAgPC9zcGFuPlxuICAgICAgPC9zcGFuPlxuICAgICk7XG5cbiAgICBpZiAoKHNvdXJjZU9mVGVybSAmJiBzb3VyY2VUZXJtQXBwZWFyKSB8fCAhc291cmNlT2ZUZXJtKSB7XG4gICAgICBuZXdUZXh0ID0gcmVwbGFjZVRleHRBdEluZGV4KFxuICAgICAgICBuZXdUZXh0LFxuICAgICAgICBpICsgaW5jcmVhc2VkVG9vbHRpcCxcbiAgICAgICAgdGVybU1hdGNoLmxlbmd0aCxcbiAgICAgICAgdG9vbHRpcENvbnRlbnRcbiAgICAgICk7XG4gICAgICBpbmNyZWFzZWRUb29sdGlwID1cbiAgICAgICAgaW5jcmVhc2VkVG9vbHRpcCArIHRvb2x0aXBDb250ZW50Lmxlbmd0aCAtIHRlcm1NYXRjaC5sZW5ndGg7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gbmV3VGV4dDtcbn07XG5leHBvcnQgZnVuY3Rpb24gZGlzcGxheUFzSFRNTChcbiAgdGV4dEFyZWFUZXh0LFxuICB0ZXJtTWF0Y2hHbG9zc2FyeSxcbiAgdGVybUxpc3QsXG4gIHNvdXJjZUNlbGwsXG4gIHRlcm1NYXRjaEdsb3NzYXJ5U291cmNlLFxuICBvcmlnaW5hbFRlcm1MaXN0XG4pIHtcbiAgbGV0IHRleHRXaXRoR2xvc3NhcnkgPSByZXBsYWNlVGV4dFdpdGhHbG9zc2FyeShcbiAgICB0ZXh0QXJlYVRleHQsXG4gICAgdGVybU1hdGNoR2xvc3NhcnksXG4gICAgdGVybUxpc3QsXG4gICAgc291cmNlQ2VsbCxcbiAgICB0ZXJtTWF0Y2hHbG9zc2FyeVNvdXJjZSxcbiAgICBvcmlnaW5hbFRlcm1MaXN0XG4gICk7XG5cbiAgbGV0IHRleHRXaXRoU3BhY2VzQmVmb3JlUHVuY3R1YXRpb25SZXBsYWNlZCA9IHRleHRXaXRoR2xvc3NhcnkucmVwbGFjZShcbiAgICAvICsoPz1bXFwuXFwhXFw/XSkvZyxcbiAgICByZXBsYWNlbWVudEZ1bmN0aW9uXG4gICk7XG5cbiAgLy8gYsO0aSDEkWVuIG5o4buvbmcgY2jhu5cgY8OzIGjGoW4gaGFpIGThuqV1IGPDoWNoIGxp4buBbi5cbiAgbGV0IHRleHRXaXRoU3BhY2VzUmVwbGFjZWQgPSB0ZXh0V2l0aFNwYWNlc0JlZm9yZVB1bmN0dWF0aW9uUmVwbGFjZWQucmVwbGFjZShcbiAgICAvKD88PSApICsvZyxcbiAgICByZXBsYWNlbWVudEZ1bmN0aW9uXG4gICk7XG5cbiAgLy8ga2hpIG7DoG8gZOG6pXUgY8OhY2ggdGjhu6thIHh14bqldCBoaeG7h24gbmdheSBzYXUgZOG6pXUgLiA/ICEsIG3DrG5oIHRoYXkgdGjhur8gZOG6pXUg4o61IMSR4bqndSB0acOqbiBi4bqxbmcgJm5ic3A7IMSR4buDIGNobyBwaMOpcCB1c2VyIGPDsyBoYWkgZOG6pXUgY8OhY2ggc2F1IC4gPyAhLlxuICBjb25zdCByZWdleCA9IG5ldyBSZWdFeHAoXCIoPzw9Wy4/IV0pIFwiICsgcmVwbGFjZW1lbnRDb2RlLCBcImdcIik7XG4gIGxldCB0ZXh0QWxsb3dpbmdEb3VibGVTcGFjZUFmdGVyRW5kT2ZTZW50ZW5jZSA9XG4gICAgdGV4dFdpdGhTcGFjZXNSZXBsYWNlZC5yZXBsYWNlKHJlZ2V4LCBcIiAmbmJzcDtcIik7XG5cbiAgLy8gdGhheSB0aOG6vyBjw6FjIGThuqV1IGPDoWNoIHRo4burYSBi4bqxbmcgZOG6pXUg4o61IG3DoHUgZOG7j1xuICBsZXQgdGV4dFdpdGhTcGFjZXNBc1VuZGVyc2NvcmVzID1cbiAgICB0ZXh0QWxsb3dpbmdEb3VibGVTcGFjZUFmdGVyRW5kT2ZTZW50ZW5jZS5yZXBsYWNlQWxsKFxuICAgICAgcmVwbGFjZW1lbnRDb2RlLFxuICAgICAgXCI8Zm9udCBjb2xvcj0jRjAwPuKOtTwvZm9udD5cIlxuICAgICk7XG5cbiAgcmV0dXJuIHRleHRXaXRoU3BhY2VzQXNVbmRlcnNjb3Jlcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNvcnRHbG9zc2FyeUxpc3QoZ2xvc3NhcnkpIHtcbiAgZ2xvc3NhcnkuZm9yRWFjaChmdW5jdGlvbiAodGVybSwgaSkge1xuICAgIGdsb3NzYXJ5W2ldID0gdGVybS50b0xvd2VyQ2FzZSgpO1xuICB9KTtcbiAgcmV0dXJuIGdsb3NzYXJ5LnNvcnQoKGEsIGIpID0+IGIubGVuZ3RoIC0gYS5sZW5ndGgpO1xufVxuXG4vKipcbiAqIEEgY29tcGxldGUgbWF0Y2ggb2YgdGVybSBpbiBzdHJpbmcgaXMgd2hlbiB0ZXJtIG1hdGNoZXMgYSBjb21wbGV0ZSB3b3JkIG9yXG4gKiBwaHJhc2UgaW4gc3RyaW5nIGFuZCBubyBwYXJ0aWFsIHdvcmRzIGluIHN0cmluZyBhcmUgbGVmdCBoYW5naW5nIG9mZiB0aGVcbiAqIHN0YXJ0IG9yIGVuZC4gRm9yIGV4YW1wbGUsIGlmIHRlcm0gaXMgXCJmdWxsXCIgYW5kIHN0cmluZyBpcyBcImJlYXV0aWZ1bGx5XCIsIHRoYXRcbiAqIGlzIG5vdCBhIGNvbXBsZXRlIG1hdGNoIGJlY2F1c2UgXCJiZWF1dGlcIiBoYW5ncyBvZmYgdGhlIGJlZ2lubmluZyBhbmQgXCJ5XCIgZXh0ZW5kc1xuICogYmVmb3JlIHRoZSBzdGFydCBvZiB0aGUgc2VjdGlvbiBvZiBtYXRjaGluZyB0ZXh0LlxuICoqL1xuZnVuY3Rpb24gY29tcGxldGVNYXRjaEJvdW5kYXJpZXMoc3RyaW5nLCBzdGFydEluZGV4LCBzZWdtZW50ZXIsIHRlcm0pIHtcbiAgLy8gaW5pdGlhbGl6ZSB2YWx1ZXMgZm9yIG91dHB1dFxuICAvLyB0aGlzIGlzIHRoZSBvdXRwdXQgYXMgaXQgc2hvdWxkIGJlIGlmIG5vIG1hdGNoIGlzIGZvdW5kXG4gIGxldCBtYXRjaEJvdW5kYXJpZXMgPSB7XG4gICAgbmFpdmVNYXRjaDogZmFsc2UsXG4gICAgY29tcGxldGVNYXRjaDogZmFsc2UsXG4gICAgbmFpdmVNYXRjaFN0YXJ0OiAtMSxcbiAgICBuYWl2ZU1hdGNoRW5kOiAtMSxcbiAgICBjb21wbGV0ZU1hdGNoU3RhcnQ6IC0xLFxuICAgIGNvbXBsZXRlTWF0Y2hFbmQ6IC0xLFxuICB9O1xuXG4gIC8vIGZpbmQgYSBtYXRjaCBieSBzaW1wbGUgc3RyaW5nIHNlYXJjaCwgc3RhcnRpbmcgYXQgc3RhcnRJbmRleC5cbiAgbGV0IHVuc2VhcmNoZWRQYXJ0T2ZTdHJpbmcgPSBzdHJpbmcuc3Vic3RyaW5nKHN0YXJ0SW5kZXgpO1xuICBsZXQgbWF0Y2hJbmRleCA9IHVuc2VhcmNoZWRQYXJ0T2ZTdHJpbmcuaW5kZXhPZih0ZXJtKSArIHN0YXJ0SW5kZXg7XG5cbiAgLy8gaWYgbm8gc2ltcGxlIG1hdGNoIHdhcyBmb3VuZCwgcmV0dXJuXG4gIGlmIChtYXRjaEluZGV4IDwgc3RhcnRJbmRleCkgcmV0dXJuIG1hdGNoQm91bmRhcmllcztcblxuICAvLyBpZiB3ZSByZWFjaCB0aGlzIHBvaW50IHRoZW4gYSBuYWl2ZSBtYXRjaCB3YXMgZm91bmQuXG4gIC8vIHVwZGF0ZSBuYWl2ZSBtYXRjaCBib3VuZGFyeSBpbmZvcm1hdGlvbiBhY2NvcmRpbmdseS5cbiAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2ggPSB0cnVlO1xuICBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaFN0YXJ0ID0gbWF0Y2hJbmRleDtcbiAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQgPSBtYXRjaEluZGV4ICsgdGVybS5sZW5ndGggLSAxO1xuXG4gIC8vIHNlZ21lbnQgdGhlIHN0cmluZ1xuICBsZXQgc3RyaW5nU2VnbWVudHMgPSBzZWdtZW50ZXIuc2VnbWVudChzdHJpbmcpO1xuXG4gIC8vIGdldCB0aGUgc3RyaW5nIHNlZ21lbnQgdGhhdCBjb250YWlucyB0aGUgbWF0Y2ggaW5kZXguXG4gIC8vIHRoaXMgaXMgdGhlIGZpcnN0IHdvcmQgaW4gc3RyaW5nIHRoYXQgbWF0Y2hlcyB0ZXJtXG4gIGxldCBmaXJzdE1hdGNoaW5nU2VnbWVudCA9IHN0cmluZ1NlZ21lbnRzLmNvbnRhaW5pbmcobWF0Y2hJbmRleCk7XG5cbiAgLy8gaWYgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGluZyBzZWdtZW50IGRvZXNuJ3QgbWF0Y2ggdGhlIG1hdGNoSW5kZXggZm91bmRcbiAgLy8gYnkgbmFpdmUgc2VhcmNoLCBpdCdzIGEgcGFydGlhbCBtYXRjaC4gUmV0dXJuIHRoZSBib3VuZGFyeSBpbmZvIGFzLWlzXG4gIC8vIHdpdGhvdXQgY29tcGxldGUgbWF0Y2ggZGF0YS5cbiAgaWYgKGZpcnN0TWF0Y2hpbmdTZWdtZW50LmluZGV4IDwgbWF0Y2hJbmRleCkgcmV0dXJuIG1hdGNoQm91bmRhcmllcztcblxuICAvKipcbiAgICogYXQgdGhpcyBwb2ludCB3ZSBrbm93IHRoYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBcInRlcm1cIiBpcyB0aGUgZmlyc3RcbiAgICogY2hhcmFjdGVyIG9mIGEgc2VnbWVudCBpbiBzdHJpbmcuIG5vdyB3ZSBuZWVkIHRvIGNoZWNrIGlmIHRoZSBsYXN0IGNoYXJhY3RlclxuICAgKiBpbiBcInRlcm1cIiBpcyBhbHNvIGFsaWduZWQgd2l0aCB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgYSBzZWdtZW50IGluIHN0cmluZy5cbiAgICoqL1xuXG4gIC8vIGdldCB0aGUgc3RyaW5nIHNlZ21lbnQgdGhhdCBjb250YWlucyB0aGUgbGFzdCBjaGFyYWN0ZXIgb2YgdGVybVxuICBsZXQgbGFzdE1hdGNoaW5nU2VnbWVudCA9IHN0cmluZ1NlZ21lbnRzLmNvbnRhaW5pbmcoXG4gICAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmRcbiAgKTtcblxuICAvLyBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IGNoYXJhY3RlciBvZiB0aGF0IHN0cmluZyBzZWdtZW50XG4gIGxldCBlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQgPVxuICAgIGxhc3RNYXRjaGluZ1NlZ21lbnQuaW5kZXggKyBsYXN0TWF0Y2hpbmdTZWdtZW50LnNlZ21lbnQubGVuZ3RoIC0gMTtcblxuICAvLyBpZiB0aGUgZW5kIG9mIHRoZSBsYXN0IG1hdGNoaW5nIHNlZ21lbnQgbWF0Y2hlcyB3aXRoIHRoZSBlbmQgb2YgdGhlIG5haXZlIFwiaW5kZXhPZlwiXG4gIC8vIG1hdGNoIHRoZW4gdGhlIG1hdGNoIGlzIGEgY29tcGxldGUgbWF0Y2ggd2l0aCBubyBleHRyYSB3b3JkIGNoYXJhY3RlcnMgaGFuZ2luZ1xuICAvLyBvZmYgdGhlIHN0YXJ0IG9yIGVuZC5cbiAgaWYgKGVuZE9mTGFzdE1hdGNoaW5nU2VnbWVudCA9PSBtYXRjaEJvdW5kYXJpZXMubmFpdmVNYXRjaEVuZCkge1xuICAgIC8vIHVwZGF0ZSB0aGUgY29tcGxldGUgbWF0Y2ggYm91bmRhcnkgaW5mb1xuICAgIG1hdGNoQm91bmRhcmllcy5jb21wbGV0ZU1hdGNoID0gdHJ1ZTtcbiAgICBtYXRjaEJvdW5kYXJpZXMuY29tcGxldGVNYXRjaFN0YXJ0ID0gZmlyc3RNYXRjaGluZ1NlZ21lbnQuaW5kZXg7XG4gICAgbWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2hFbmQgPSBlbmRPZkxhc3RNYXRjaGluZ1NlZ21lbnQ7XG4gIH1cblxuICByZXR1cm4gbWF0Y2hCb3VuZGFyaWVzO1xufVxuXG4vKipcbiAqIFNlYXJjaGVzIFwic3RyaW5nXCIgZm9yIHRlcm1zIGluIFwiZ2xvc3NhcnlcIiBhbmQgZ2l2ZXMgdGhlIGxvY2F0aW9uIHdoZXJlIGVhY2ggdGVybSBhcHBlYXJzLiBJZiBzZXZlcmFsIGdsb3NzYXJ5IHRlcm1zIG92ZXJsYXAsIG1hdGNoaW5nIG9uIHRoZSBzYW1lIHdvcmRzIHRoZW4gdGhlIGxvbmdlc3QgdGVybSB0YWtlcyBwcmVjZWRlbmNlLlxuICpcbiAqIEBwYXJhbSBzdHJpbmcgLSB0aGUgdGV4dCBzdHJpbmcgaW4gd2hpY2ggd2Ugd2FudCB0byBzZWFyY2ggZm9yIGdsb3NzYXJ5IHRlcm1zXG4gKiBAcGFyYW0gZ2xvc3NhcnkgLSBhbiBhcnJheSBvZiB0ZXh0IHN0cmluZ3MsIGFsbCB0aGUgdGVybXMgaW4gdGhlIGdsb3NzYXJ5LiBUaGlzIGxpc3QgbWF5IGNvbnRhaW4gc2V2ZXJhbCB0aG91c2FuZCBpdGVtcy5cbiAqIEBwYXJhbSBsYW5ndWFnZUNvZGUgLSBJU08gNjM5LTEgbGFuZ3VhZ2UgY29kZVxuICogQHJldHVybnMge2FycmF5fSAtIGEgbGlzdCBvZiBwYWlycyBbaW5kZXgsIHRlcm1dIHdoZXJlIGludCBpcyB0aGUgaW5kZXggYXQgd2hpY2ggdGVybSBhcHBlYXJzIGluIHN0cmluZy5cbiAqKi9cbmZ1bmN0aW9uIGdsb3NzYXJ5TWF0Y2hlcyhcbiAgc3RyaW5nLFxuICBhbGxHbG9zc2FyeSxcbiAgY2FzZVNlbnNpdGl2ZSA9IGZhbHNlLFxuICB0ZXh0SW5mbyxcbiAgb3JpZ2luYWxUZXJtTGlzdFxuKSB7XG4gIC8vIG1ha2UgYSBjb3B5IG9mIHN0cmluZyBzbyB0aGF0IHRoZSBvcmlnaW5hbCBpcyBub3QgbG9zdCB3aGVuIHdlIG1vZGlmeSBpdFxuICBsZXQgc3RyaW5nQ29weSA9IHN0cmluZztcbiAgLy8gaWYgdGhlIHNlYXJjaCBpcyBub3QgY2FzZS1zZW5zaXRpdmUsIGNvbnZlcnQgZXZlcnl0aGluZyB0byBsb3dlciBjYXNlXG4gIGlmICghY2FzZVNlbnNpdGl2ZSkge1xuICAgIHN0cmluZyA9IHN0cmluZy50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgLy8gc3BsaXQgdGhlIHN0cmluZyBpbnRvIHNlZ21lbnRzLCBzZXBhcmF0aW5nIGJ5IHdvcmRcbiAgbGV0IHNlZ21lbnRlciA9IG5ldyBJbnRsLlNlZ21lbnRlcih0ZXh0SW5mby5sYW5ndWFnZSwge1xuICAgIGdyYW51bGFyaXR5OiBcIndvcmRcIixcbiAgfSk7XG5cbiAgbGV0IG91dHB1dCA9IEFycmF5KDApO1xuXG4gIC8vIGZvciBlYWNoIGxpc3Qgb2YgdGVybXMgaW4gdGhlIHNvcnRlZCBnbG9zc2FyeVxuICBhbGxHbG9zc2FyeT8uc3JjR2xvc3NhcnkuZm9yRWFjaChmdW5jdGlvbiAodGVybSkge1xuICAgIC8vIHdlIHN0YXJ0IHNlYXJjaGluZyBmb3IgXCJ0ZXJtXCIgc3RhcnRpbmcgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIFwic3RyaW5nXCJcbiAgICBsZXQgc2VhcmNoU3RhcnRJbmRleCA9IDA7XG5cbiAgICAvLyBmaW5kIHRoZSBsb2NhdGlvbiBpbiBcInN0cmluZ1wiIHdoZXJlIHRoZSBcInRlcm1cIiBpcyBmb3VuZFxuICAgIGxldCBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgIHN0cmluZyxcbiAgICAgIHNlYXJjaFN0YXJ0SW5kZXgsXG4gICAgICBzZWdtZW50ZXIsXG4gICAgICB0ZXJtXG4gICAgKTtcblxuICAgIC8vIGlmIFwidGVybVwiIHdhcyBmb3VuZCBpbiBcInN0cmluZ1wiIGJ5IG5haXZlIGluZGV4T2Ygc2VhcmNoXG4gICAgd2hpbGUgKFxuICAgICAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2ggJiZcbiAgICAgIHRleHRJbmZvLmxhbmd1YWdlID09PSBvcmlnaW5hbFRlcm1MaXN0WzBdLnNvdXJjZUxhbmd1YWdlXG4gICAgKSB7XG4gICAgICAvLyBzaW5jZSBhIG5haXZlIG1hdGNoIHdhcyBmb3VuZCwgd2UgdXBkYXRlIHRoZSBzZWFyY2hTdGFydEluZGV4IHRvIHByZXZlbnRcbiAgICAgIC8vIGZpbmRpbmcgdGhhdCBzYW1lIG5haXZlIG1hdGNoIGFnYWluIGluIHRoZSBmdXR1cmUuXG4gICAgICBzZWFyY2hTdGFydEluZGV4ID0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQgKyAxO1xuXG4gICAgICAvLyBpZiB0aGUgbWF0Y2ggaXMgYSBjb21wbGV0ZSBtYXRjaCwgcmVjb3JkIGl0LCB0aGVuIGVyYXNlIGl0IGZyb20gc3RyaW5nIHRvXG4gICAgICAvLyBwcmV2ZW50IHNob3J0ZXIgdGVybXMgZnJvbSBkb3VibGUtbWF0Y2hpbmcgb24gaXQgbGF0ZXIgb24uXG4gICAgICBpZiAobWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgICAgLy8gZ2V0IGEgc2hvcnRlciB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kZXggd2hlcmUgdGhlIG5haXZlIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICBsZXQgbWF0Y2hJbmRleCA9IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoU3RhcnQ7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCB0ZXJtIGZyb20gdGhlIGNvcHkgb2Ygc3RyaW5nLCBpbiBjYXNlIHRoZSBjYXNlLWluc2VudGl0aXZlXG4gICAgICAgIC8vIHNlYXJjaCBjYXVzZWQgdGhlIHN0cmluZyB0byBiZSBtb2RpZmllZFxuICAgICAgICBsZXQgb3JpZ2luYWxUZXJtID0gc3RyaW5nQ29weS5zdWJzdHJpbmcoXG4gICAgICAgICAgbWF0Y2hJbmRleCxcbiAgICAgICAgICBtYXRjaEluZGV4ICsgdGVybS5sZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHRlcm0gdG8gdGhlIG91dHB1dCBsaXN0XG4gICAgICAgIG91dHB1dC5wdXNoKFttYXRjaEluZGV4LCBvcmlnaW5hbFRlcm1dKTtcblxuICAgICAgICAvLyBFcmFzZSB0aGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzIGluIHN0cmluZyBzbyB0aGF0IHN1YnNlcXVlbnRcbiAgICAgICAgLy8gdGVybXMgaW4gdGhlIGdsb3NzYXJ5IGNhbid0IG1hdGNoIHdpdGggdGhlIHNhbWUgdGV4dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQmVjYXVzZSBvdXIgZ2xvc3NhcnkgaXMgc29ydGVkIHdpdGggbG9uZ2VzdCB0ZXJtcyBmaXJzdCxcbiAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgbG9uZ2VyIG1hdGNoZXMgdGFrZSBwcmVjZW5kZW5jZSBvdmVyIHNob3J0ZXJcbiAgICAgICAgLy8gb25lcy5cbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UodGVybSwgXCIgXCIucmVwZWF0KHRlcm0ubGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgb3RoZXIgcGxhY2VzIGluIFwic3RyaW5nXCIgdGhhdCBtYXRjaCBcInRlcm1cIi5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSwgdGhlIHdoaWxlIGxvb3Agd2lsbCByZXBlYXQuXG4gICAgICBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICBzZWFyY2hTdGFydEluZGV4LFxuICAgICAgICBzZWdtZW50ZXIsXG4gICAgICAgIHRlcm1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICBhbGxHbG9zc2FyeT8udGFyZ2V0R2xvc3NhcnkuZm9yRWFjaChmdW5jdGlvbiAodGVybSkge1xuICAgIC8vIHdlIHN0YXJ0IHNlYXJjaGluZyBmb3IgXCJ0ZXJtXCIgc3RhcnRpbmcgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIFwic3RyaW5nXCJcbiAgICBsZXQgc2VhcmNoU3RhcnRJbmRleCA9IDA7XG5cbiAgICAvLyBmaW5kIHRoZSBsb2NhdGlvbiBpbiBcInN0cmluZ1wiIHdoZXJlIHRoZSBcInRlcm1cIiBpcyBmb3VuZFxuICAgIGxldCBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgIHN0cmluZyxcbiAgICAgIHNlYXJjaFN0YXJ0SW5kZXgsXG4gICAgICBzZWdtZW50ZXIsXG4gICAgICB0ZXJtXG4gICAgKTtcblxuICAgIC8vIGlmIFwidGVybVwiIHdhcyBmb3VuZCBpbiBcInN0cmluZ1wiIGJ5IG5haXZlIGluZGV4T2Ygc2VhcmNoXG4gICAgd2hpbGUgKFxuICAgICAgbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2ggJiZcbiAgICAgIHRleHRJbmZvLmxhbmd1YWdlID09PSBvcmlnaW5hbFRlcm1MaXN0WzBdLnRhcmdldExhbmd1YWdlXG4gICAgKSB7XG4gICAgICAvLyBzaW5jZSBhIG5haXZlIG1hdGNoIHdhcyBmb3VuZCwgd2UgdXBkYXRlIHRoZSBzZWFyY2hTdGFydEluZGV4IHRvIHByZXZlbnRcbiAgICAgIC8vIGZpbmRpbmcgdGhhdCBzYW1lIG5haXZlIG1hdGNoIGFnYWluIGluIHRoZSBmdXR1cmUuXG4gICAgICBzZWFyY2hTdGFydEluZGV4ID0gbWF0Y2hCb3VuZGFyaWVzLm5haXZlTWF0Y2hFbmQgKyAxO1xuXG4gICAgICAvLyBpZiB0aGUgbWF0Y2ggaXMgYSBjb21wbGV0ZSBtYXRjaCwgcmVjb3JkIGl0LCB0aGVuIGVyYXNlIGl0IGZyb20gc3RyaW5nIHRvXG4gICAgICAvLyBwcmV2ZW50IHNob3J0ZXIgdGVybXMgZnJvbSBkb3VibGUtbWF0Y2hpbmcgb24gaXQgbGF0ZXIgb24uXG4gICAgICBpZiAobWF0Y2hCb3VuZGFyaWVzLmNvbXBsZXRlTWF0Y2gpIHtcbiAgICAgICAgLy8gZ2V0IGEgc2hvcnRlciB2YXJpYWJsZSBuYW1lIGZvciB0aGUgaW5kZXggd2hlcmUgdGhlIG5haXZlIG1hdGNoIHdhcyBmb3VuZFxuICAgICAgICBsZXQgbWF0Y2hJbmRleCA9IG1hdGNoQm91bmRhcmllcy5uYWl2ZU1hdGNoU3RhcnQ7XG5cbiAgICAgICAgLy8gZ2V0IHRoZSBvcmlnaW5hbCB0ZXJtIGZyb20gdGhlIGNvcHkgb2Ygc3RyaW5nLCBpbiBjYXNlIHRoZSBjYXNlLWluc2VudGl0aXZlXG4gICAgICAgIC8vIHNlYXJjaCBjYXVzZWQgdGhlIHN0cmluZyB0byBiZSBtb2RpZmllZFxuICAgICAgICBsZXQgb3JpZ2luYWxUZXJtID0gc3RyaW5nQ29weS5zdWJzdHJpbmcoXG4gICAgICAgICAgbWF0Y2hJbmRleCxcbiAgICAgICAgICBtYXRjaEluZGV4ICsgdGVybS5sZW5ndGhcbiAgICAgICAgKTtcblxuICAgICAgICAvLyBhZGQgdGhlIHRlcm0gdG8gdGhlIG91dHB1dCBsaXN0XG4gICAgICAgIG91dHB1dC5wdXNoKFttYXRjaEluZGV4LCBvcmlnaW5hbFRlcm1dKTtcblxuICAgICAgICAvLyBFcmFzZSB0aGUgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzIGluIHN0cmluZyBzbyB0aGF0IHN1YnNlcXVlbnRcbiAgICAgICAgLy8gdGVybXMgaW4gdGhlIGdsb3NzYXJ5IGNhbid0IG1hdGNoIHdpdGggdGhlIHNhbWUgdGV4dC5cbiAgICAgICAgLy9cbiAgICAgICAgLy8gQmVjYXVzZSBvdXIgZ2xvc3NhcnkgaXMgc29ydGVkIHdpdGggbG9uZ2VzdCB0ZXJtcyBmaXJzdCxcbiAgICAgICAgLy8gdGhpcyBlbnN1cmVzIHRoYXQgbG9uZ2VyIG1hdGNoZXMgdGFrZSBwcmVjZW5kZW5jZSBvdmVyIHNob3J0ZXJcbiAgICAgICAgLy8gb25lcy5cbiAgICAgICAgc3RyaW5nID0gc3RyaW5nLnJlcGxhY2UodGVybSwgXCIgXCIucmVwZWF0KHRlcm0ubGVuZ3RoKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGNoZWNrIHRvIHNlZSBpZiB0aGVyZSBhcmUgb3RoZXIgcGxhY2VzIGluIFwic3RyaW5nXCIgdGhhdCBtYXRjaCBcInRlcm1cIi5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSwgdGhlIHdoaWxlIGxvb3Agd2lsbCByZXBlYXQuXG4gICAgICBtYXRjaEJvdW5kYXJpZXMgPSBjb21wbGV0ZU1hdGNoQm91bmRhcmllcyhcbiAgICAgICAgc3RyaW5nLFxuICAgICAgICBzZWFyY2hTdGFydEluZGV4LFxuICAgICAgICBzZWdtZW50ZXIsXG4gICAgICAgIHRlcm1cbiAgICAgICk7XG4gICAgfVxuICB9KTtcblxuICAvLyBzb3J0IHRoZSBvdXRwdXQgYnkgdGhlIGluZGljZXMgYW5kIHJldHVyblxuICByZXR1cm4gb3V0cHV0LnNvcnQoKGEsIGIpID0+IGFbMF0gLSBiWzBdKTtcbn1cblxuZXhwb3J0IGNvbnN0IGRldGVjdEdsb3NzYXJ5ID0gKFxuICB0ZXh0LFxuICBnbG9zc2FyeSxcbiAgdGV4dEluZm8sXG4gIG9yaWdpbmFsVGVybUxpc3QsXG4gIHRlcm1Tb3VyY2VNYXRjaEdsb3NzYXJ5XG4pID0+IHtcbiAgbGV0IGNhc2VTZW5zaXRpdmUgPSBmYWxzZTtcblxuICBpZiAodGV4dCkge1xuICAgIHJldHVybiBnbG9zc2FyeU1hdGNoZXMoXG4gICAgICB0ZXh0LFxuICAgICAgZ2xvc3NhcnksXG4gICAgICBjYXNlU2Vuc2l0aXZlLFxuICAgICAgdGV4dEluZm8sXG4gICAgICBvcmlnaW5hbFRlcm1MaXN0LFxuICAgICAgdGVybVNvdXJjZU1hdGNoR2xvc3NhcnlcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBbXTtcbiAgfVxufTtcbiJdLCJuYW1lcyI6WyJyZXBsYWNlVGV4dEF0SW5kZXgiLCJyZW5kZXJUb1N0cmluZyIsInJlcGxhY2VtZW50Q29kZSIsInJlcGxhY2VtZW50RnVuY3Rpb24iLCJtIiwicmVwZWF0IiwibGVuZ3RoIiwicmVwbGFjZVRleHRXaXRoR2xvc3NhcnkiLCJ0ZXh0IiwidGVybU1hdGNoR2xvc3NhcnkiLCJ0ZXJtTGlzdCIsInNvdXJjZUNlbGwiLCJnbG9zc2FyeSIsIm9yaWdpbmFsVGVybUxpc3QiLCJuZXdUZXh0IiwiaW5jcmVhc2VkVG9vbHRpcCIsImZvckVhY2giLCJpIiwidGVybU1hdGNoIiwidHJhbmxhdGlvbk9mVGVybSIsInNvdXJjZU9mVGVybSIsInRlcm1Ob3RlIiwic291cmNlVGVybUFwcGVhciIsInRlcm0iLCJzb3VyY2VWYWx1ZXMiLCJzb21lIiwidmFsdWUiLCJ0b0xvd2VyQ2FzZSIsInRyYW5zbGF0aW9ucyIsIm5vdGUiLCJjb25zb2xlIiwibG9nIiwidGVybU1hdGNoR2xvc3NhcnlTb3VyY2UiLCJ2YWx1ZTIiLCJ2YWx1ZTEiLCJfIiwidG9vbHRpcENvbnRlbnQiLCJzcGFuIiwiY2xhc3NOYW1lIiwiYiIsImRpdiIsImpvaW4iLCJkaXNwbGF5QXNIVE1MIiwidGV4dEFyZWFUZXh0IiwidGV4dFdpdGhHbG9zc2FyeSIsInRleHRXaXRoU3BhY2VzQmVmb3JlUHVuY3R1YXRpb25SZXBsYWNlZCIsInJlcGxhY2UiLCJ0ZXh0V2l0aFNwYWNlc1JlcGxhY2VkIiwicmVnZXgiLCJSZWdFeHAiLCJ0ZXh0QWxsb3dpbmdEb3VibGVTcGFjZUFmdGVyRW5kT2ZTZW50ZW5jZSIsInRleHRXaXRoU3BhY2VzQXNVbmRlcnNjb3JlcyIsInJlcGxhY2VBbGwiLCJzb3J0R2xvc3NhcnlMaXN0Iiwic29ydCIsImEiLCJjb21wbGV0ZU1hdGNoQm91bmRhcmllcyIsInN0cmluZyIsInN0YXJ0SW5kZXgiLCJzZWdtZW50ZXIiLCJtYXRjaEJvdW5kYXJpZXMiLCJuYWl2ZU1hdGNoIiwiY29tcGxldGVNYXRjaCIsIm5haXZlTWF0Y2hTdGFydCIsIm5haXZlTWF0Y2hFbmQiLCJjb21wbGV0ZU1hdGNoU3RhcnQiLCJjb21wbGV0ZU1hdGNoRW5kIiwidW5zZWFyY2hlZFBhcnRPZlN0cmluZyIsInN1YnN0cmluZyIsIm1hdGNoSW5kZXgiLCJpbmRleE9mIiwic3RyaW5nU2VnbWVudHMiLCJzZWdtZW50IiwiZmlyc3RNYXRjaGluZ1NlZ21lbnQiLCJjb250YWluaW5nIiwiaW5kZXgiLCJsYXN0TWF0Y2hpbmdTZWdtZW50IiwiZW5kT2ZMYXN0TWF0Y2hpbmdTZWdtZW50IiwiZ2xvc3NhcnlNYXRjaGVzIiwiYWxsR2xvc3NhcnkiLCJjYXNlU2Vuc2l0aXZlIiwidGV4dEluZm8iLCJzdHJpbmdDb3B5IiwiSW50bCIsIlNlZ21lbnRlciIsImxhbmd1YWdlIiwiZ3JhbnVsYXJpdHkiLCJvdXRwdXQiLCJBcnJheSIsInNyY0dsb3NzYXJ5Iiwic2VhcmNoU3RhcnRJbmRleCIsInNvdXJjZUxhbmd1YWdlIiwib3JpZ2luYWxUZXJtIiwicHVzaCIsInRhcmdldEdsb3NzYXJ5IiwidGFyZ2V0TGFuZ3VhZ2UiLCJkZXRlY3RHbG9zc2FyeSIsInRlcm1Tb3VyY2VNYXRjaEdsb3NzYXJ5Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./utils/glossaryUtils.js\n"));

/***/ })

});